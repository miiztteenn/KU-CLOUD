/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "http://localhost:8080/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 408);
/******/ })
/************************************************************************/
/******/ ({

/***/ 12:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 188:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if("undefined"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Depricated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(b,c,d){var e=new XMLHttpRequest;e.open("GET",b),e.responseType="blob",e.onload=function(){a(e.response,c,d)},e.onerror=function(){console.error("could not download file")},e.send()}function d(a){var b=new XMLHttpRequest;return b.open("HEAD",a,!1),b.send(),200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,a=f.saveAs||"object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(a,b,d,e){if(e=e||open("","_blank"),e&&(e.document.title=e.document.body.innerText="downloading..."),"string"==typeof a)return c(a,b,d);var g="application/octet-stream"===a.type,h=/constructor/i.test(f.HTMLElement)||f.safari,i=/CriOS\/[\d]+/.test(navigator.userAgent);if((i||g&&h)&&"object"==typeof FileReader){var j=new FileReader;j.onloadend=function(){var a=j.result;a=i?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),e?e.location.href=a:location=a,e=null},j.readAsDataURL(a)}else{var k=f.URL||f.webkitURL,l=k.createObjectURL(a);e?e.location=l:location.href=l,e=null,setTimeout(function(){k.revokeObjectURL(l)},4E4)}};f.saveAs=a.saveAs=a,"undefined"!=typeof module&&(module.exports=a)});

//# sourceMappingURL=FileSaver.min.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6);


/***/ }),

/***/ 408:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(409);


/***/ }),

/***/ 409:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_file_saver__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_file_saver___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_file_saver__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





var API = {
    getDataById: 'analysis/data/',
    analysisProcess: "analysis",
    getTraningFile: "analysis/data"
};

validate.validators.presence.message = "is required";

var validateInput = {
    process: {
        parent: "#input_analysis",
        validate: {
            training_file: {
                presence: {
                    allowEmpty: false
                }
            }
        }
    }
};

var Regression = function Regression() {
    var _this = this;

    _classCallCheck(this, Regression);

    var el = {
        number_of_folds: $("#number_of_folds"),
        random_number_seed: $("#random_number_seed")
    };

    this.type = 'regression';
    this.number_of_folds = el.number_of_folds.val();
    this.random_number_seed = el.random_number_seed.val();

    var chart_linear = null;

    var self = this;

    this.bindElement = function () {
        el.number_of_folds.change(function () {
            self.number_of_folds = $(this).val();
        });

        el.random_number_seed.change(function () {
            self.random_number_seed = $(this).val();
        });
    };

    this.writeOutput = function (output) {
        var outputHtml = "";
        var cross_validation = output.cross_validation.value;
        outputHtml = '<h4>' + output.linear_regression.header + '</h4>\n                          <p>' + output.linear_regression.value + '</p>\n                          <br>\n                          <h4>Cross-validation</h4>\n                          <br>\n                          <div class="table-responsive">\n                            <table class="table table-bordered">\n                                <tbody>\n                                    <tr>\n                                        <td>' + cross_validation[0].text + '</td>\n                                        <td align="right">' + cross_validation[0].val + ' ' + cross_validation[0].unit + '</td>\n                                    </tr>\n                                    <tr>\n                                        <td>' + cross_validation[1].text + '</td>\n                                        <td align="right">' + cross_validation[1].val + ' ' + cross_validation[1].unit + '</td>\n                                    </tr>\n                                    <tr>\n                                        <td>' + cross_validation[2].text + '</td>\n                                        <td align="right">' + cross_validation[2].val + ' ' + cross_validation[2].unit + '</td>\n                                    </tr>\n                                    <tr>\n                                        <td>' + cross_validation[3].text + '</td>\n                                        <td align="right">' + cross_validation[3].val + ' ' + cross_validation[3].unit + '</td>\n                                    </tr>\n                                    <tr>\n                                        <td>' + cross_validation[4].text + '</td>\n                                        <td align="right">' + cross_validation[4].val + ' ' + cross_validation[4].unit + '</td>\n                                    </tr>\n                                    <tr>\n                                        <td>' + cross_validation[5].text + '</td>\n                                        <td align="right">' + cross_validation[5].val + ' ' + cross_validation[5].unit + '</td>\n                                    </tr>\n                                </tbody>\n                            </tabel>\n                          </div>\n                         ';
        $("#outputHtml").html(outputHtml);

        createChart(output);
    };

    var createChart = function createChart(output) {
        if (chart_linear == null) {
            var ctx = document.getElementById("chart_linear").getContext('2d');

            chart_linear = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: "",
                        backgroundColor: 'rgb(255, 255, 255,0)',
                        borderColor: '#2196F3',
                        data: []
                    }]
                },
                options: {
                    tooltips: {
                        callbacks: {
                            title: function title(tooltipItem, data) {
                                return data.datasets[0].label;
                            },
                            label: function label(tooltipItem, data) {
                                console.log(data);
                                return "x : " + data['datasets'][0]['data'][tooltipItem['index']].x + " , " + "y : " + data['datasets'][0]['data'][tooltipItem['index']].y;
                            }

                        }
                    },
                    scales: {
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: 'y-axis'
                            },
                            ticks: {
                                beginAtZero: true
                            }
                        }],
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: 'x-axis'
                            },
                            type: 'linear',
                            display: true,
                            position: 'bottom'
                        }]
                    }
                }
            });
        }
        updateChart(output);
    };

    var updateChart = function updateChart(output) {
        chart_linear.data.datasets[0].data = [];

        chart_linear.data.datasets[0].label = output.linear_regression.value;

        chart_linear.data.datasets[0].data.push({
            x: output.plot.max.x,
            y: output.plot.max.y
        });

        chart_linear.data.datasets[0].data.push({
            x: output.plot.min.x,
            y: output.plot.min.y
        });

        chart_linear.update();
    };

    this.getValue = function () {
        return {
            type: _this.type,
            number_of_folds: _this.number_of_folds,
            random_number_seed: _this.random_number_seed
        };
    };
};

var Cluster = function Cluster() {
    var _this2 = this;

    _classCallCheck(this, Cluster);

    var el = {
        number_of_clusters: $("#number_of_clusters"),
        method: $("#method"),
        max_candidates: $("#max_candidates"),
        min_density: $("#min_density")
    };

    this.type = 'cluster';
    this.number_of_clusters = el.number_of_clusters.val();
    this.method = el.method.val();
    this.max_candidates = el.max_candidates.val();
    this.min_density = el.min_density.val();

    var self = this;

    this.bindElement = function () {
        el.number_of_clusters.change(function () {
            self.number_of_clusters = $(this).val();
        });

        el.method.change(function () {
            self.method = $(this).val();
        });

        el.max_candidates.change(function () {
            self.max_candidates = $(this).val();
        });

        el.min_density.change(function () {
            self.min_density = $(this).val();
        });
    };

    var createTableCluster = function createTableCluster(finalCluster, clusters) {
        var table = $("#outputFinalCluster").html('<table class="table table-bordered table-striped">\n                                                        <thead></thead>\n                                                        <tbody></tbody>\n                                                       </table>');
        var thead = table.find('thead');
        thead.append('<tr><th rowspan="4" style="vertical-align : middle;text-align:center;">Attribute</th></tr>');
        thead.append('<tr align="center"><th colspan="' + (clusters + 1) + '">Cluster#</th></tr>');
        var html = '<tr align="center"><th>Full data</th>';
        finalCluster[1].map(function (_data) {
            if (_data !== 'Attribute' && _data !== 'Data' && _data !== 'Full') {
                html += '<th>' + _data + '</th>';
            }
        });
        html += "</tr>";
        thead.append(html);

        html = '<tr align="center">';
        finalCluster[2].map(function (_data) {
            html += '<th>' + _data + '</th>';
        });
        html += "</tr>";
        thead.append(html);

        var tbody = table.find('tbody');
        for (var i = 3; i < finalCluster.length; i++) {
            tbody.append('<tr align="center"></tr>');
            var tr = tbody.find('tr:last');
            var td = "";
            finalCluster[i].map(function (_data) {
                td += '<td>' + _data + '</td>';
            });
            tr.append(td);
        }
    };

    var createTalbeClusteredInstances = function createTalbeClusteredInstances(output) {
        var html = '<table class="table table-bordered table-striped">\n                            <thead>\n                                <tr>\n                                    <th>Clustered</th>\n                                    <th>Instances</th>\n                                    <th>Instances (%)</th>\n                                </tr>\n                            </thead>\n                            <tbody>\n                            </tody>\n                        </table>';
        var table = $("#clustered_instances").html(html);
        var tbody = table.find("tbody");
        var value = "";
        var i = 0;
        output.map(function (_data) {
            value = "";
            tbody.append('<tr></tr>');
            _data.map(function (_val) {
                if (i != 2) {
                    value += '<td>' + _val + '</td>';
                } else {
                    value += '<td  align="right">' + _val + '</td>';
                }
                i++;
            });
            i = 0;
            tbody.find('tr:last').html(value);
        });
    };

    this.writeOutput = function (output) {
        var clusters = output.clusters;
        var key = Object.keys(clusters);
        key.map(function (_key) {
            clusters[_key].map(function (_data) {});
        });
        var outputHtml = '\n                <p>Number of iterations: ' + output.number_of_iterations.value + '</p>\n                <p>Within cluster sum of squared errors: ' + output.within_cluster_sum_of_squared_errors.value + '</p>\n                <br>\n                <h4>Final cluster centroids:</h4>\n                <br>\n                <div id="outputFinalCluster" class="table-responsive"></div>\n                <br>\n                <h4>Clustering stats for training data</h4>\n                <br>\n                <div id="clustered_instances" class="table-responsive"></div>\n\n            ';
        $("#outputHtml").html(outputHtml);
        createTableCluster(output.final_cluster_centroids.value, Object.keys(output.clusters).length);
        createTalbeClusteredInstances(output.clustered_instances.value);
    };

    this.getValue = function () {
        return {
            type: _this2.type,
            number_of_clusters: _this2.number_of_clusters,
            method: _this2.method,
            max_candidates: _this2.max_candidates,
            min_density: _this2.min_density
        };
    };
};

var Associate = function Associate() {
    var _this3 = this;

    _classCallCheck(this, Associate);

    var el = {
        number_of_rules: $("#number_of_rules"),
        metric_type: $("#metric_type"),
        minimum_confidence: $("#minimum_confidence"),
        delta_for_minimum_support: $("#delta_for_minimum_support"),
        upper_for_minimum_support: $("#upper_for_minimum_support"),
        lower_for_minimum_support: $("#lower_for_minimum_support")
    };

    this.type = 'associate';
    this.number_of_rules = el.number_of_rules.val();
    this.metric_type = el.metric_type.val();
    this.minimum_confidence = el.minimum_confidence.val();
    this.delta_for_minimum_support = el.delta_for_minimum_support.val();
    this.upper_for_minimum_support = el.upper_for_minimum_support.val();
    this.lower_for_minimum_support = el.lower_for_minimum_support.val();

    var self = this;

    this.bindElement = function () {
        el.number_of_rules.change(function () {
            self.number_of_rules = $(this).val();
        });

        el.metric_type.change(function () {
            self.metric_type = $(this).val();
        });

        el.minimum_confidence.change(function () {
            self.minimum_confidence = $(this).val();
        });

        el.delta_for_minimum_support.change(function () {
            self.delta_for_minimum_support = $(this).val();
        });

        el.upper_for_minimum_support.change(function () {
            self.upper_for_minimum_support = $(this).val();
        });

        el.lower_for_minimum_support.change(function () {
            self.lower_for_minimum_support = $(this).val();
        });
    };

    this.getValue = function () {
        return {
            type: _this3.type,
            number_of_rules: _this3.number_of_rules,
            metric_type: _this3.metric_type,
            minimum_confidence: _this3.minimum_confidence,
            delta_for_minimum_support: _this3.delta_for_minimum_support,
            upper_for_minimum_support: _this3.upper_for_minimum_support,
            lower_for_minimum_support: _this3.lower_for_minimum_support
        };
    };

    this.writeOutput = function (output) {
        var outputHtml = '\n            <p>Minimum support : ' + output.minimum_support.value + '</p>\n            <p>Minimum metric : ' + output.minimum_metric_confidence.value + '</p>\n            <br>\n            <p>Number of cycles performed : ' + output.number_of_cycles_performed.value + '</p>\n            <br>\n            <h4>Generated sets of large itemsets:</h4>\n            <br>\n            <div class="table-responsive">\n                <table class="table table-bordered" id="table_itemsets">\n                    <tbody>\n                    </tbody>\n                </table>\n            </div>\n            <br>\n            <h4>Best rules found :</h4>\n            <br>\n                <div class="table-responsive">\n                    <table class="table table-bordered table-striped" id="table_rule">\n                        <thead>\n                            <tr>\n                                <th rowspan="3" style="vertical-align : middle;text-align:center;">Rule No.</th>\n                            </tr>\n                            <tr align="center">\n                                <th colspan="2">Rule</th>\n                            </tr>\n                            <tr align="center">\n                                <th>Left</th>\n                                <th>Right</th>\n                                <th >lift</th>\n                                <th>lev</th>\n                                <th>conv</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                        </tbody>\n                    </table>\n                </div>\n            <br>\n            <p><b>Elapsed time : </b> ' + output.elapsed_time.value + '</p>\n                \n            ';
        $("#outputHtml").html(outputHtml);

        var table_itemsets = $("#table_itemsets").find('tbody');
        var generated_sets_of_large_itemsets = output.Generated_sets_of_large_itemsets;
        var key = Object.keys(generated_sets_of_large_itemsets);

        key.map(function (_key) {
            table_itemsets.append('<tr></tr>');
            var tr = table_itemsets.find('tr:last');
            tr.append('<td>' + generated_sets_of_large_itemsets[_key].text + '</td>\n                           <td align="right">' + generated_sets_of_large_itemsets[_key].value + '</td>');
        });

        var table_rule = $("#table_rule").find('tbody');
        var best_rules_found = output.Best_rules_found;
        key = Object.keys(best_rules_found);

        key.map(function (_key) {
            table_rule.append('<tr></tr>');
            var tr = table_rule.find('tr:last');
            tr.append('\n                            <td style="vertical-align : middle;text-align:center;">' + _key + '</td>\n                            <td>' + best_rules_found[_key].leftRule + '</td>\n                            <td>' + best_rules_found[_key].rightRule + '</td>\n                            <td align="right">' + parseFloat(best_rules_found[_key].lift).toFixed(2) + '</td>\n                            <td align="right">' + parseFloat(best_rules_found[_key].lev).toFixed(2) + '</td>\n                            <td align="right">' + parseFloat(best_rules_found[_key].conv).toFixed(2) + '</td>\n                           ');
        });
    };
};

var J48 = function J48() {
    var _this4 = this;

    _classCallCheck(this, J48);

    var el = {
        confidence_threshold: $("#confidence_threshold"),
        minimum_number_of_instances: $("#minimum_number_of_instances"),
        number_of_folds: $("#number_of_folds")
    };

    this.type = 'J48';
    this.confidence_threshold = el.confidence_threshold.val();
    this.minimum_number_of_instances = el.minimum_number_of_instances.val();
    this.number_of_folds = el.number_of_folds.val();

    var chart_accuracy = null;

    var self = this;

    this.bindElement = function () {
        el.confidence_threshold.change(function () {
            self.confidence_threshold = $(this).val();
        });

        el.minimum_number_of_instances.change(function () {
            self.minimum_number_of_instances = $(this).val();
        });

        el.number_of_folds.change(function () {
            self.number_of_folds = $(this).val();
        });
    };

    this.crateChartAccuracy = function (output) {
        var data = [];
        var className = Object.keys(output.detailed_accuracy_by_class.class);
        className.map(function (_key) {
            data.push([parseFloat(output.detailed_accuracy_by_class.tp_rate[_key].value), parseFloat(output.detailed_accuracy_by_class.fp_rate[_key].value), parseFloat(output.detailed_accuracy_by_class.precision[_key].value), parseFloat(output.detailed_accuracy_by_class.recall[_key].value), parseFloat(output.detailed_accuracy_by_class['f-measure'][_key].value), parseFloat(output.detailed_accuracy_by_class.mcc[_key].value), parseFloat(output.detailed_accuracy_by_class.roc_area[_key].value), parseFloat(output.detailed_accuracy_by_class.prc_area[_key].value)]);
        });

        chart_accuracy = null;
        var ctx = document.getElementById("chart_accuracy").getContext('2d');
        chart_accuracy = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ["TP Rate", "FP Rate", "Precision", "Recall", "F-Measure", "MCC", "ROC Area", "PRC Area"],
                datasets: []
            },
            options: {
                scales: {
                    yAxes: [{
                        ticks: {
                            beginAtZero: true
                        }
                    }]
                }
            }
        });

        chart_accuracy.data.datasets = [];

        console.log(data);
        data.map(function (_data, index) {
            var backgroundColor = [];
            var borderColor = [];
            var color = Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["j" /* randomHexColor */])();

            _data.map(function (_d) {
                backgroundColor.push(Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["e" /* convertHex */])(color, 20));
                borderColor.push(color);
            });

            chart_accuracy.data.datasets.push({
                label: output.detailed_accuracy_by_class.class[index].value === null ? 'Avg.' : output.detailed_accuracy_by_class.class[index].value,
                data: _data.slice(),
                backgroundColor: backgroundColor.slice(),
                borderColor: borderColor.slice(),
                borderWidth: 1
            });
        });

        chart_accuracy.update();
    };

    this.writeOutput = function (output) {
        var confusion_matrix = output.confusion_matrix.join("\r\n");
        var className = Object.keys(output.detailed_accuracy_by_class.class);
        var outHtml = '\n            <h4>Classifier model (full training set)</h4>\n            <br>\n            <h4>J48 pruned tree <i class="fas fa-arrow-down download-file grow" id="download_tree" data-toggle="tooltip" data-placement="top" title="Download tree images"></i></h4>\n            <br>\n            <div id="graph" style="text-align: center; overflow-y:auto"></div>\n            <br>\n            <p>Number of Leaves : ' + output.j48_pruned_tree.number_of_leaves + '</p>\n            <p>Size of the tree  : ' + output.j48_pruned_tree.size_of_the_tree + '</p>\n            <br>\n            <h4>Stratified cross-validation</h4>\n            <br>\n            <div class="table-responsive">\n                <table class="table table-bordered">\n                    <tbody>\n                        <tr>\n                            <td>Correctly Classified Instances</td>\n                            <td>' + output.stratified_cross_validation.correctly_classified_instances.value + ' ' + output.stratified_cross_validation.correctly_classified_instances.type + ' ' + output.stratified_cross_validation.correctly_classified_instances.instances + '  Instance</td>\n                        </tr>\n                        <tr>\n                            <td>Incorrectly Classified Instances</td>\n                            <td>' + output.stratified_cross_validation.incorrectly_classified_instances.value + ' ' + output.stratified_cross_validation.incorrectly_classified_instances.type + ' ' + output.stratified_cross_validation.incorrectly_classified_instances.instances + ' Instance</td>\n                        </tr>\n                        <tr>\n                            <td>Kappa statistic</td>\n                            <td>' + output.stratified_cross_validation.kappa_statistic.value + '</td>\n                        </tr>\n                        <tr>\n                            <td>Mean absolute error</td>\n                            <td>' + output.stratified_cross_validation.mean_absolute_error.value + '</td>\n                        </tr>\n                        <tr>\n                            <td>Root mean squared error</td>\n                            <td>' + output.stratified_cross_validation.root_mean_squared_error.value + '</td>\n                        </tr>\n                        <tr>\n                            <td>Relative absolute error</td>\n                            <td>' + output.stratified_cross_validation.relative_absolute_error.value + ' ' + output.stratified_cross_validation.relative_absolute_error.type + '</td>\n                        </tr>\n                        <tr>\n                            <td>Root relative squared error</td>\n                            <td>' + output.stratified_cross_validation.root_relative_squared_error.value + ' ' + output.stratified_cross_validation.relative_absolute_error.type + '</td>\n                        </tr>\n                        <tr>\n                            <td>Total Number of Instances</td>\n                            <td>' + output.stratified_cross_validation.total_number_of_instances.value + '</td>\n                        </tr>\n                    </tbody>\n                <table>\n            </div>\n            <br>\n            <h4>Detailed Accuracy By Class</h4>\n            <br>\n            <canvas id="chart_accuracy" style="height:200px"></canvas>\n            <br>\n            <div class="table-responsive">\n                <table class="table table-bordered" id="accuracy_by_class">\n                    <thead>\n                        <tr>\n                            <th></th>\n                            <th>TP Rate <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FN )"></i></th>\n                            <th>FP Rate <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="FP / ( FP + TN )"></i></th>\n                            <th>Precision <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FP )"></i></th>\n                            <th>Recall <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FN )"></i></th>\n                            <th>F-Measure <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content=" 2 x Precision x Recall / (Precision + Recall)"></i></th>\n                            <th>MCC</th>\n                            <th>ROC Area</th>\n                            <th>PRC Area</th>\n                            <th>Class</th>\n                        <tr>\n                    </thead>\n                    <tbody>\n\n                    </tbody>\n                </table>\n            </div>\n            <br>\n            <h4>Confusion Matrix</h4>\n            <pre>' + confusion_matrix + '</pre>\n            ';
        $("#outputHtml").html(outHtml);

        var table = $("#accuracy_by_class");
        var tbody = table.find('tbody');
        className.map(function (_class, index) {
            tbody.append('<tr></tr>');
            var tr = tbody.find('tr:last');
            console.log(tr);
            tr.html('   <td>' + (index + 1 === className.length ? 'Weighted Avg.' : '') + '</td>\n                            <td>' + output.detailed_accuracy_by_class.tp_rate[_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class.fp_rate[_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class.precision[_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class.recall[_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class['f-measure'][_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class.mcc[_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class.roc_area[_class].value + '</td>\n                            <td>' + output.detailed_accuracy_by_class.prc_area[_class].value + '</td>\n                            <td>' + (output.detailed_accuracy_by_class.class[_class].value == null ? '' : output.detailed_accuracy_by_class.class[_class].value) + '</td>');
        });

        $('[data-toggle="popover"]').popover({
            trigger: "hover",
            html: true
        });

        $('[data-toggle="tooltip"]').tooltip();

        $("#download_tree").unbind().click(function () {
            var target = document.getElementById("graph");

            html2canvas(target).then(function (canvas) {
                saveAs(canvas.toDataURL(), 'file-name.png');
            });
        });

        d3.select("#graph").graphviz().fade(false).renderDot(output.tree);
        _this4.crateChartAccuracy(output);
    };

    this.getValue = function () {
        return {
            type: _this4.type,
            confidence_threshold: _this4.confidence_threshold,
            minimum_number_of_instances: _this4.minimum_number_of_instances,
            number_of_folds: _this4.number_of_folds
        };
    };
};

var state = {
    tabSelect: 'classify-tab',
    outputCluster: null,
    axis_x: 0,
    axis_y: 0
};

var Visualize = function Visualize() {
    _classCallCheck(this, Visualize);

    var el = {
        axis_x: $("#axis_x"),
        axis_y: $("#axis_y")
    };
    var axis_x = el.axis_x.val();
    var axis_y = el.axis_y.val();
    var scatter_chart = null;

    var colors = ['#E53935', '#1E88E5', '#43A047', '#FB8C00', '#28a745', '#ffc107', '#17a2b8', '#fd7e14', '#6610f2', '#dc3545'];

    var instance_number = [];

    var self = this;

    var clusters = null;

    var optionsChart = {
        responsive: true

    };

    var createScatterChart = function createScatterChart() {
        if (scatter_chart === null) {
            var ctx = document.getElementById("scatter_chart").getContext('2d');
            scatter_chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{}]
                },
                options: optionsChart
            });
        } else {
            scatter_chart.data.datasets = [{}];
            scatter_chart.update();
        }
        el.axis_x.change();
    };

    var updataChart = function updataChart() {
        if (scatter_chart != null) {
            var data = [];

            var keyCluster = Object.keys(clusters);

            var _loop = function _loop(i) {
                var obj = [];
                clusters[keyCluster[i]].map(function (_data) {
                    obj.push({
                        x: _data.values[state.axis_x],
                        y: _data.values[state.axis_y]
                    });
                });
                data.push(obj);
            };

            for (var i = 0; i < keyCluster.length; i++) {
                _loop(i);
            }

            for (var i = 0; i < data.length; i++) {

                for (var j = 0; j < data[i].length; j++) {
                    if (isNaN(data[i][j].x)) {
                        for (var x = 0; x < state.outputCluster.header.attributes[state.axis_x].labels.length; x++) {

                            if (data[i][j].x === state.outputCluster.header.attributes[state.axis_x].labels[x]) {
                                data[i][j].x = x;
                            }
                        }
                    } else {
                        data[i][j].x = parseFloat(data[i][j].x);
                    }

                    if (isNaN(data[i][j].y)) {
                        for (var y = 0; y < state.outputCluster.header.attributes[state.axis_y].labels.length; y++) {

                            if (data[i][j].y === state.outputCluster.header.attributes[state.axis_y].labels[y]) {
                                data[i][j].y = y;
                            }
                        }
                    } else {
                        data[i][j].y = parseFloat(data[i][j].y);
                    }
                }
            }

            var datasets = [];
            data.map(function (_data, index) {
                var ran = Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["i" /* getRndInteger */])(5, 15);
                datasets.push({
                    label: 'Cluster' + index,
                    data: _data,
                    pointHoverRadius: ran,
                    pointRadius: ran,
                    borderColor: colors[index],
                    backgroundColor: Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["e" /* convertHex */])(colors[index], 40)
                });
            });

            scatter_chart.data.datasets = datasets;
            scatter_chart.update();

            var _optionsChart = {
                responsive: true,
                scales: {
                    xAxes: [{
                        ticks: {
                            // Include a dollar sign in the ticks
                            callback: function callback(value, index) {
                                if (state.outputCluster.header.attributes[state.axis_x].type !== "numeric") {
                                    return state.outputCluster.header.attributes[state.axis_x].labels[value];
                                } else {
                                    return value;
                                }
                            }
                        }
                    }],
                    yAxes: [{
                        ticks: {
                            // Include a dollar sign in the ticks
                            callback: function callback(value, index) {
                                if (state.outputCluster.header.attributes[state.axis_y].type !== "numeric") {
                                    return state.outputCluster.header.attributes[state.axis_y].labels[value];
                                } else {
                                    return value;
                                }
                            }
                        }
                    }]
                }

            };
            scatter_chart.options = _optionsChart;
            scatter_chart.update();
        }
    };

    this.bindElement = function () {
        el.axis_x.change(function () {
            state.axis_x = $(this).val();
            if (scatter_chart != null) {
                updataChart();
            }
        });

        el.axis_y.change(function () {
            state.axis_y = $(this).val();
            if (scatter_chart != null) {
                updataChart();
            }
        });
    };

    this.createAxis = function (output) {
        state.outputCluster = output.outputCluster;
        var html = "";
        output.outputCluster.header.attributes.map(function (attr, index) {
            html += '<option value="' + index + '">' + attr.name + '</option>';
        });

        el.axis_x.html(html);
        el.axis_y.html(html);

        for (var i = 0; i < output.outputCluster.data.length; i++) {
            instance_number.push(i);
        }

        clusters = _.groupBy(output.outputCluster.data, function (d) {
            return d.values[d.values.length - 1];
        });

        createScatterChart();
    };
};

var Analysis = function Analysis() {
    _classCallCheck(this, Analysis);

    var cluster = new Cluster();
    var associate = new Associate();
    var visualize = new Visualize();
    var regression = new Regression();
    var j48 = new J48();

    var traningFile = null;
    var output = null;
    var traningFileSelect = "";

    var dataTable = null;
    var datasources = {};
    var data = null;

    var createTableData = function createTableData() {
        dataTable = $("#dataTable");
        var thead = dataTable.find('thead');
        thead.empty();
        var tbody = dataTable.find('tbody');
        tbody.empty();
        thead.append('<tr></tr>');
        var tr = thead.find('tr:last');
        tr.append('<th>#</th>');
        data.data.header.attributes.map(function (_data) {
            tr.append('<th>' + _data.name + '</th>');
        });

        data.data.data.map(function (_data, index) {
            tbody.append('<tr></tr>');
            var tr = tbody.find('tr:last');
            tr.append('<td>' + (index + 1) + '</td>');
            _data.values.map(function (_value) {
                tr.append('<td>' + _value + '</td>');
            });
        });

        dataTable.parent().show();
        dataTable = $('#dataTable').dataTable({});
    };

    var bindElement = function bindElement() {

        Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["b" /* addEventValidate */])(validateInput.process);

        $("#btn_process").unbind().click(function () {
            analysisProcess();
        });

        // $(".cancel-getFile").unbind().click(function(){

        //     $('#dataTable').dataTable().fnDestroy();

        //     if(this.ajaxGetDataById != null){
        //         this.ajaxGetDataById.abort();
        //     }

        //     $(this).hide();
        // });

        $(".tab-basic .nav-link").unbind().click(function () {
            $("#outputText").html('');
            $("#outputHtml").html('');
            $(".result").hide();
            state.tabSelect = $(this).attr('id');
            d3.select('#graph').selectAll('svg').remove();
            $("#visualize").hide();
            $("#chart_regression").hide();
        });

        $("#training_file").change(function () {
            var _this5 = this;

            traningFileSelect = $(this).val();

            if (dataTable != null) {

                $('#dataTable').dataTable().fnDestroy();
            }

            if (this.ajaxGetDataById != null) {
                this.ajaxGetDataById.abort;
            }

            dataTable = $("#dataTable");
            dataTable.parent().hide();
            var thead = dataTable.find('thead');
            thead.empty();
            var tbody = dataTable.find('tbody');
            tbody.empty();

            if (traningFileSelect != "" && !datasources[traningFileSelect]) {
                $(this).prop('disabled', true);
                //$(".cancel-getFile").show();
                $("body").find('.lds-roller').show();
                this.ajaxGetDataById = $.ajax({
                    url: '' + END_POINT + API.getDataById + traningFileSelect,
                    method: 'GET',
                    success: function success(res, textStatus, xhr) {
                        Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["c" /* checkAuthRes */])(xhr);
                        $("body").find('.lds-roller').hide();
                        data = res.data;
                        datasources[traningFileSelect] = res.data;
                        createTableData();
                        $(_this5).prop('disabled', false);
                        //$(".cancel-getFile").hide();
                    },
                    error: function error(res) {
                        console.log(res);
                    }
                });
            } else if (datasources[traningFileSelect]) {
                data = datasources[traningFileSelect];
                createTableData();
            }
        });

        $(".download-file").unbind().click(function () {
            downloadFileResult($(this).attr('type'));
        });
    };

    var downloadFileResult = function downloadFileResult(type) {
        if (type === 'text') {
            var blob = new Blob([output.outputText.join("\r\n")], {
                type: "text/plain;charset=utf-8"
            });
            __WEBPACK_IMPORTED_MODULE_1_file_saver___default.a.saveAs(blob, 'file_result.txt');
        } else if (type === 'json') {
            var _blob = new Blob([JSON.stringify(output, null, '        ')], {
                type: "text/plain;charset=utf-8"
            });
            __WEBPACK_IMPORTED_MODULE_1_file_saver___default.a.saveAs(_blob, 'file_result.json');
        }
        return;
    };

    var writeOutputHtml = function writeOutputHtml() {
        var outHtml = "";
        if (state.tabSelect === 'cluster-tab') {
            cluster.writeOutput(output);
        } else if (state.tabSelect === 'regression-tab') {
            regression.writeOutput(output);
        } else if (state.tabSelect === 'associate-tab') {
            associate.writeOutput(output);
        } else if (state.tabSelect === 'classify-tab') {
            j48.writeOutput(output);
        }
    };

    var writeOutput = function writeOutput() {
        var outputText = output.outputText;
        var textarea = "";
        outputText.map(function (text) {
            textarea += text + "\n";
        });
        $(".result").show();
        $("#outputText").html(textarea);

        if (state.tabSelect === 'cluster-tab') {
            $("#visualize").show();
            visualize.createAxis(output);
        } else if (state.tabSelect === 'classify-tab') {} else if (state.tabSelect === 'regression-tab') {
            $("#chart_regression").show();
        } else {
            $("#visualize").hide();
            $("#chart_regression").hide();
        }
        writeOutputHtml();
    };

    var analysisProcess = function analysisProcess() {
        var data = {};
        var dataInput = null;
        if (Object(__WEBPACK_IMPORTED_MODULE_0__utility_js__["d" /* checkError */])(validateInput.process)) return;
        if (state.tabSelect === 'cluster-tab') {
            dataInput = cluster.getValue();
        } else if (state.tabSelect === 'regression-tab') {
            dataInput = regression.getValue();
        } else if (state.tabSelect === 'associate-tab') {
            dataInput = associate.getValue();
        } else if (state.tabSelect === 'classify-tab') {
            dataInput = j48.getValue();
        }

        data = {
            type: dataInput.type,
            traningFile: traningFileSelect,
            param: dataInput
        };

        __WEBPACK_IMPORTED_MODULE_0__utility_js__["a" /* LOADING */].set($("#btn_process"));
        d3.select('#graph').selectAll('svg').remove();
        $.ajax({
            url: END_POINT + API.analysisProcess,
            method: 'POST',
            data: data,
            success: function success(res) {
                output = res.data;
                console.log(output);
                if (output.outputText.length > 0) {
                    writeOutput();
                }
                __WEBPACK_IMPORTED_MODULE_0__utility_js__["a" /* LOADING */].reset($("#btn_process"));
            },
            timeout: 30000,
            error: function error(res) {
                console.log(res);
                __WEBPACK_IMPORTED_MODULE_0__utility_js__["a" /* LOADING */].reset($("#btn_process"));
            }
        });
    };

    var createSelectTraningFile = function createSelectTraningFile() {
        var html = "<option value=''>--Select training file--</option>";
        traningFile.map(function (file) {
            html += '<option value="' + file.data_id + '">' + file.name + '</option>';
        });
        $("#training_file").html(html);
    };

    var getTraningFile = function getTraningFile() {
        $.ajax({
            url: END_POINT + API.getTraningFile,
            success: function success(res) {
                traningFile = res.data;
                console.log(traningFile);
                createSelectTraningFile();
            },
            error: function error(res) {
                console.log(res);
            }
        });
    };

    this.initAndRun = function () {
        bindElement();
        cluster.bindElement();
        regression.bindElement();
        associate.bindElement();
        visualize.bindElement();
        getTraningFile();
    };
};

$(document).ready(function () {
    var analysis = new Analysis();
    analysis.initAndRun();
});

/***/ }),

/***/ 5:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export showLoadingModal */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return deepCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return convertHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return randomHexColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LOADING; });
/* unused harmony export getTime */
/* unused harmony export aproximateHour */
/* unused harmony export filter_hour */
/* unused harmony export ERROR_INPUT */
/* harmony export (immutable) */ __webpack_exports__["b"] = addEventValidate;
/* harmony export (immutable) */ __webpack_exports__["d"] = checkError;
/* harmony export (immutable) */ __webpack_exports__["l"] = showErrorsForInputCustom;
/* harmony export (immutable) */ __webpack_exports__["k"] = resetInputValidate;
/* harmony export (immutable) */ __webpack_exports__["g"] = getFlatObject;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getFlatObjectV2; });
/* harmony export (immutable) */ __webpack_exports__["i"] = getRndInteger;
/* unused harmony export diff_hours */
/* harmony export (immutable) */ __webpack_exports__["c"] = checkAuthRes;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _asyncToGenerator(fn) {
    return function () {
        var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
            function step(key, arg) {
                try {
                    var info = gen[key](arg);var value = info.value;
                } catch (error) {
                    reject(error);return;
                }if (info.done) {
                    resolve(value);
                } else {
                    return Promise.resolve(value).then(function (value) {
                        step("next", value);
                    }, function (err) {
                        step("throw", err);
                    });
                }
            }return step("next");
        });
    };
}

var showLoadingModal = function showLoadingModal(el, status) {
    var loading = " <div id=\"loading-save\" style=\"display:none;\">\n                        <div class=\"lds-ring\">\n                            <div></div>\n                            <div></div>\n                            <div></div>\n                            <div></div>\n                        </div>\n                        <h6 class='text-center'>Saving Data ...</h6>\n                    </div>";
    var _el = el;

    if (!_el.find("#loading-save").length) {
        _el.find(".modal-body").after(loading);
    }

    if (status) {
        _el.find("form").hide();
        _el.find(".modal-footer").hide();
        _el.find("#loading-save").show();
    } else {
        _el.find("form").show();
        _el.find(".modal-footer").show();
        _el.find("#loading-save").hide();
    }
};

var deepCopy = function deepCopy(data) {
    return data.map(function (item) {
        return Object.assign({}, item);
    });
};

var convertHex = function convertHex(hex, opacity) {
    hex = hex.replace('#', '');
    var r = parseInt(hex.substring(0, 2), 16);
    var g = parseInt(hex.substring(2, 4), 16);
    var b = parseInt(hex.substring(4, 6), 16);

    var result = 'rgba(' + r + ',' + g + ',' + b + ',' + opacity / 100 + ')';
    return result;
};

var randomHexColor = function randomHexColor() {
    return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);
};

var resetText = null;

var LOADING = {
    set: function set(el) {
        resetText = el.html();
        var textLoading = el.attr('data-loading-text');
        el.html(textLoading);
        el.prop('disabled', true);
    },
    reset: function reset(el) {
        el.html(resetText);
        el.prop('disabled', false);
    }
};

function getTime(hours, minutes) {
    var time = null;
    minutes = minutes + "";
    if (hours < 12) {
        time = "AM";
    } else {
        time = "PM";
    }
    if (hours == 0) {
        hours = 12;
    }
    if (hours > 12) {
        hours = hours - 12;
    }
    if (minutes.length == 1) {
        minutes = "0" + minutes;
    }
    return hours + ":" + minutes + " " + time;
}

function aproximateHour(mins) {
    var minutes = Math.round(mins % 60);
    if (minutes == 60 || minutes == 0) {
        return mins / 60;
    }
    return Math.trunc(mins / 60) + minutes / 100;
}

function filter_hour(value, type) {
    return value % 60 == 0 ? 1 : 0;
}

var ERROR_INPUT = {
    set: function set(target, errorList) {
        $(".text-alert").remove();
        Object.keys(target).map(function (key) {
            if (errorList[key]) {
                $(target[key].el).removeClass('input-error');
                $(target[key].el).addClass('input-error');
                $(target[key].el).after("<p class=\"text-alert small\" style=\"color:red\">" + errorList[key] + "</p>");

                $(target[key].el).focus(function () {
                    $(target[key].el).removeClass('input-error');
                    $(target[key].el).next(".text-alert").remove();
                });

                setTimeout(function () {
                    $(target[key].el).removeClass('input-error');
                    $(".text-alert").remove();
                }, 6000);
            }
        });
    },
    reset: function reset(el) {
        $(el).removeClass('input-error');
        $(".text-alert").remove();
    }
};

function addEventValidate(validateInput) {
    var inputs = $(validateInput.parent).find("input, textarea, select");
    $(validateInput.parent).on('change', 'input, textarea, select', function () {
        var elInput = $(this);
        var check = {};
        var attr = "";
        //inputs.each(function () {
        attr = $(this).attr('name');
        var val = $(this).val();
        // console.log(val)
        check[attr] = val == '' ? null : val;
        //})
        var errors = validate(check, validateInput.validate) || {};
        console.log(elInput, errors);
        showErrorsForInput(elInput, errors[elInput.attr('name')]);
    });

    // inputs.each(function () {
    //     $(this).change(function () {
    //         // let attr = $(this).attr('name');
    //         // let val = $(this).val();
    //         // let check = {};
    //         // check[attr] = val == '' ? null : val;
    //         // let errors = validate(check, validateInput.validate) || {};
    //         // console.log(attr, check[attr], errors);
    //         // showErrorsForInput($(this), errors[attr]);
    //         let elInput = $(this);
    //         let check = {};
    //         let attr = "";
    //         //inputs.each(function () {
    //             attr = $(this).attr('name');
    //             let val = $(this).val();
    //             console.log(val)
    //             check[attr] = val == '' ? null : val;
    //        // })
    //         let errors = validate(check, validateInput.validate) || {};
    //         console.log(elInput, errors);
    //         showErrorsForInput(elInput, errors[elInput.attr('name')]);
    //     });
    // })
}

function showErrors(validateInput, errors) {
    var inputs = $(validateInput.parent).find("input, textarea, select");
    console.log(errors);
    // let isError = true;
    // inputs.each(function () {
    //     let attr = $(this).attr('name');
    //     let val = $(this).val();
    //     let check = {};
    //     check[attr] = val == '' ? null : val;
    //     let errors = validate(check, validateInput.validate) || {};
    //     showErrorsForInput($(this), errors[attr]);
    // })
    // return isError;
    var key = Object.keys(errors);
    inputs.each(function () {
        var elInput = $(this);
        var attr = elInput.attr('name');
        key.map(function (_key) {
            if (_key === attr) {
                showErrorsForInput(elInput, errors[attr]);
            }
        });
    });
}

function checkError(validateInput) {
    var inputs = $(validateInput.parent).find("input, textarea, select");
    var isError = true;
    var check = {};
    inputs.each(function () {
        var attr = $(this).attr('name');
        var val = $(this).val();
        check[attr] = val == '' ? null : val;
    });
    var errors = validate(check, validateInput.validate) || {};
    if (!validate.isEmpty(errors)) {
        showErrors(validateInput, errors);
        isError = true;
    } else {
        isError = false;
    }
    return isError;
}

// Shows the errors for a specific input
function showErrorsForInput(input, errors) {
    if (!validate.isEmpty(errors)) {
        input.removeClass("has-success");
        input.addClass("has-error");
        if (input.parent().find(".messages-error").length > 0) {
            //input.parent().addClass("has-error");
            input.parent().find(".messages-error").html(errors[0]);
        } else {
            //input.parent().addClass("has-error");
            input.parent().parent().find(".messages-error").html(errors[0]);
        }
    } else {
        input.removeClass("has-error");
        input.addClass("has-success");
        if (input.parent().find(".messages-error").length > 0) {
            //input.parent().addClass("has-success");
            input.parent().find(".messages-error").html('');
        } else {
            //input.parent().addClass("has-success");
            input.parent().parent().find(".messages-error").html('');
        }
    }
}

function showErrorsForInputCustom(input, errors) {
    //console.log(input, errors);
    if (!validate.isEmpty(errors)) {
        input.removeClass("has-success");
        input.addClass("has-error");
        input.parent().find(".messages-error").html(errors);
    } else {
        input.removeClass("has-error");
        input.addClass("has-success");
        input.parent().find(".messages-error").html('');
    }
}

function resetInputValidate() {
    $("input, textarea, select").removeClass('has-success');
    $("input, textarea, select").removeClass('has-error');
    $(".messages-error").html('');
}

function getFlatObject(object) {
    function iter(o, p) {
        if (Array.isArray(o)) {
            o.forEach(function (a, i) {
                iter(a, p.concat(i));
            });
            return;
        }
        if (o !== null && (typeof o === "undefined" ? "undefined" : _typeof(o)) === 'object') {
            Object.keys(o).forEach(function (k) {
                iter(o[k], p.concat(k));
            });
            return;
        }
        path[p.join('/')] = o;
    }

    var path = {};
    iter(object, []);
    return path;
}

var getFlatObjectV2 = function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee(object) {
        var iter, path;
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        iter = function iter(o, p) {
                            if (Array.isArray(o)) {
                                o.forEach(function (a, i) {
                                    iter(a, p.concat(i));
                                });
                                return;
                            }
                            if (o !== null && (typeof o === "undefined" ? "undefined" : _typeof(o)) === 'object') {
                                Object.keys(o).forEach(function (k) {
                                    iter(o[k], p.concat(k));
                                });
                                return;
                            }
                            path[p.join('.')] = o;
                        };

                        path = {};

                        iter(object, []);
                        return _context.abrupt("return", path);

                    case 4:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function getFlatObjectV2(_x) {
        return _ref.apply(this, arguments);
    };
}();

function getRndInteger(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function diff_hours(dt2, dt1) {

    var diff = (dt2.getTime() - dt1.getTime()) / 1000;
    diff /= 60 * 60;
    return Math.abs(Math.round(diff));
}

function checkAuthRes(xhr) {
    if (xhr.getResponseHeader('authorization')) {
        var token = xhr.getResponseHeader('authorization').split(" ")[1];
        // $.ajax({
        //     url : "http://localhost:8000/SetCookie",
        //     method:"POST",
        //     data : {
        //         token : token
        //     },
        //     success : (res) => {
        //         console.log(res);
        //     },
        //     error :(res) =>{
        //         console.log(res)
        //     }
        // })
        setCookie('token', token);
    }
}

/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var regeneratorRuntime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : {}
));


/***/ })

/******/ });