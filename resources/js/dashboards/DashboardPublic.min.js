import {
    deepCopy,
    convertHex,
    randomHexColor,
    aproximateHour,
    filter_hour,
    diff_hours,
    getRndInteger,
    checkAuthRes,
    getFlatObject,
    getFlatObjectV2
} from '../utility';

import axios from 'axios';

import {
    json2excel
} from 'js2excel'

import FileSaver from 'file-saver';

import objectPath from 'object-path';



import {
    elements
} from '../company/dashboards/viewBase.min.js'

import {
    isBuffer
} from 'util';


let socket_dashboards = null;

import chart from 'chartjs-plugin-zoom';
//import ChartRealtime from 'chartjs-plugin-streaming';
Chart.defaults.global.defaultFontFamily = "'Poppins', 'Kanit', 'sans-serif'";


const API = {
    getStatic: "dashboards/public/",
    getWebServices: "company/webservices",
    getDatasource: "datasources/public",
    addDatasource: "datasources",
    deleteDatasource: "datasources",
    saveGrid: "static/dashboard",
}

let Datasource = null;

const REG = /([a-zA-Z0-9_]+)/g;



const WIDGET_TYPE = {
    BAR: 'Bar',
    MUTILINE: 'MutiLine',
    MUTILINE_STATIC: 'MutiLine_static',
    TEXTLINE: 'TextLine',
    RADAR: 'Radar',
    RADAR_STATIC: 'Radar_static',
    GAUGES: 'Gauges',
    MAP: 'Map',
    MAP_STATIC: 'Map_static',
    TEXTVALUE: 'TextValue',
    TABLE: 'Table',
    TABLE_STATIC: 'Table_static',
    TEXTBOX: 'TextBox',
};

let PERIOD = {
    TODAY: 'Today',
    YESTERDAY: 'Yesterday',
    CURRENT_WEEK: 'Current Week',
    WEEK_1: '1 Week',
    WEEK_2: '2 Week',
    WEEK_4: '4 Week',
    CURRENT_MONTH: 'Current Month',
    LAST_MONTH: 'Last Month',
    MONTH_3: '3 Month',
    MONTH_6: '6 Month',
    MONTH_12: '12 Month',
    CUSTOM: 'Custom'
}


let radarEx = null;

let state = {
    loadingApi: false,
    firstTime: true,
    firstLoadData: true,
    value_datasource_input: 0,
    allDatasource: {
        web_services: [],
        iot_services: [],
    },
    editModalIdSelect: null,
    dashboard: null,
}


class Widget {
    constructor(widget, gridData = null) {

        this.itemId = widget.itemId;
        this.widgetId = widget.widgetId;
        this.apiName = widget.apiName;
        this.datasources = widget.datasources;
        this.type = widget.type;
        this.lastUpdateId = widget.lastUpdateId;
        this.title_name = widget.title_name;
        this.lastUpdate = widget.lastUpdate;
        this.timeInterval = widget.timeInterval;
        this.wi = widget.wi;
        this.download = widget.download;
        this.gridData = gridData;

        this.updateLastUpdate = (time = null) => {
            if (time) {
                this.lastUpdate = new Date(time);
                $("#" + this.lastUpdateId).html(this.lastUpdate.toDateString() + " " + this.lastUpdate.toLocaleTimeString());
            } else {
                this.lastUpdate = new Date();
                $("#" + this.lastUpdateId).html(this.lastUpdate.toDateString() + " " + this.lastUpdate.toLocaleTimeString());
            }
        };

        let options = {
            cellHeight: 80,
            verticalMargin: 10,
            float: false
        };

        let items = [{
            x: 0,
            y: 0,
            width: 6,
            height: 7,
        }];

        let grid = null;

        

        let generateId = () => {
            let id = Math.floor(100000 + Math.random() * 900000);
            let type = this.type.toLowerCase();
            this.itemId = `item-${id}`;
            this.widgetId = `${type}-${id}`;
            this.lastUpdateId = `${type}-lastupdate-${id}`;
            this.editModalId = `editWidget_${type}_${id}`
        };

        let onEditWidgetClick = (el) => {

        };

        this.sendUpdateSocket = () => {
            this.datasources.map(_d => {
                state.dashboard.pushAllDatasource(_d.id, _d.type);
            });
           
           socket_dashboards.emit('update-datasources', state.allDatasource);
        }

        let bindWidgetElement = () => {

            $("#type_report").change(function () {
                let footer = $(this).parent().parent();
                let val = $(this).val();
                footer.find(".daily").hide();
                footer.find(".monthly").hide();
                footer.find(".yearly").hide();
                if (val === "daily") {
                    footer.find(".daily").show();
                } else if (val === "monthly") {
                    footer.find(".monthly").show();
                } else if (val === "yearly") {
                    footer.find(".yearly").show();
                }
            });

           

            $(".btn-full-screen").unbind().click(function () {
                onFullScreenClick($(this));
            });

            $(".btn-download").unbind().click(function () {
                let widget = Dashboard.getWidgetById($(this).attr('item'));
                let target = state.selectItemId ? document.getElementById(widget.timeSeries) : document.getElementById(widget.widgetId);

                html2canvas(target).then(canvas => {
                    FileSaver.saveAs(canvas.toDataURL(), 'file-name.png');
                });
            });

            $(".btn-download-excel").unbind().click(function () {
                let widget = Dashboard.getWidgetById($(this).attr('item'));
                widget.exportToExcel();
            });

            $(".btn-time-series").unbind().click(function () {
                $(this).next().toggle();
                let item = $(this).attr("item");
                let obj = Dashboard.getWidgetById(item);
                let footer = $(this).parent().parent().parent();
                let download = $("#" + item).find(".download");

                if (footer.hasClass('active-time')) {
                    download.hide();
                    state.selectItemId = null;
                    $(`#${obj.widgetId}`).show();
                    $(`#${obj.timeSeries}`).hide();
                    footer.removeClass('active-time')
                } else {
                    download.show();
                    state.selectItemId = item;
                    $(`#${obj.widgetId}`).hide();
                    $(`#${obj.timeSeries}`).show();
                    footer.addClass('active-time');
                }

                footer.find('.time-series-static').slideToggle('fast', function () {
                    if ($(this).is(':visible'))
                        obj.fullChart.resize();
                });

            });

            $(".period").unbind().change(function () {
                let period_custom = $(this).parent().parent().find('.period-custom');
                let item = $(this).attr('item');
                let widget = Dashboard.getWidgetById(item);
                widget.periodType = $(this).val();
                if ($(this).val() === PERIOD.CUSTOM) {
                    period_custom.show();
                } else {
                    period_custom.hide();
                }
                let today = new Date();
                switch ($(this).val()) {
                    case PERIOD.TODAY:
                        console.log(moment(today).format('YYYY-MM-DD'));
                        break;
                    case PERIOD.YESTERDAY:
                        console.log(moment(today).subtract(1, 'days').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.CURRENT_WEEK:
                        console.log(moment(today).startOf('week').format('YYYY-MM-DD'), moment(today).endOf('week').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.WEEK_1:
                        console.log(moment(today).subtract(7, 'days').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.WEEK_2:
                        console.log(moment(today).subtract(14, 'days').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.WEEK_4:
                        console.log(moment(today).subtract(28, 'days').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.CURRENT_MONTH:
                        console.log(moment(today).startOf('month').format('YYYY-MM-DD'), moment(today).endOf('month').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.LAST_MONTH:
                        console.log(moment(today).subtract(1, 'months').startOf('month').format('YYYY-MM-DD'), moment(today).subtract(1, 'months').endOf('month').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.MONTH_3:
                        console.log(moment(today).subtract(90, 'days').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.MONTH_6:
                        console.log(moment(today).subtract(180, 'days').format('YYYY-MM-DD'));
                        break;
                    case PERIOD.MONTH_12:
                        console.log(moment(today).subtract(360, 'days').format('YYYY-MM-DD'));
                        break;
                    default:
                        break;
                }

                widget.updateTimeSeries();
            });


            $(".start_date").unbind().change(function () {
                let period_custom = $(this).parent().parent().find('.period-custom');
                let item = $(this).attr('item');
            })

            $(".start_date").unbind().change(function () {
                let period_custom = $(this).parent().parent().find('.period-custom');
                let item = $(this).attr('item');
            })

            // if (this.sliderTime) {
            //     this.sliderTime.noUiSlider.on('update', function (values, handle) {
            //         getValueTimeSeries();
            //     });

            //     $(".static_date").change(function () {
            //         let obj = Dashboard.getWidgetById(state.selectItemId);
            //         let time = obj.sliderTime.noUiSlider.get();
            //         if (time) {
            //             getValueTimeSeries();
            //         }
            //         return;
            //     });
            // }
        };

        let getValueTimeSeries = () => {
            try {
                let obj = Dashboard.getWidgetById(state.selectItemId);
                obj.updateTimeSeries();
            } catch (error) {

            }
        }

        let onFullScreenClick = (el) => {
            let obj = Dashboard.getWidgetById(el.attr("item"));
            $("#modal_full_screen").modal('show');
            $("#content-widget").html(obj.selectWiContentFull());
            obj.createFullWidget();
        };

        

        let submitDeleteWidget = (el) => {
            let item = $(el).attr("item");
            grid.removeWidget($('#' + item).closest(".grid-stack-item"));
            let index = widgetList.findIndex(widget => widget.itemId == item);
            widgetList.splice(index, 1);
        };

        this.selectWiContent = () => {
            let valueId = "";
            let unitId = "";
            switch (this.type) {
                case WIDGET_TYPE.MUTILINE:
                    this.timeSeries = `time-${this.widgetId}`;
                    return `<canvas id="${this.widgetId}"></canvas><canvas id="${this.timeSeries}" style="display:none"></canvas>`;
                case WIDGET_TYPE.MUTILINE_STATIC:
                    return `<canvas id="${this.widgetId}"></canvas>`;
                case WIDGET_TYPE.TEXTLINE:
                    valueId = this.itemId.replace("item-", "value-");
                    unitId = this.itemId.replace("item-", "unit-");
                    return ` <h2 class="text-left"><span id="${valueId}">0</span> <span  id="${unitId}">${this.unit}</span></h2>
                             <canvas id="${this.widgetId}"></canvas>
                            `;
                case WIDGET_TYPE.RADAR:
                    return `<canvas id="${this.widgetId}"></canvas>`;
                case WIDGET_TYPE.GAUGES:
                    valueId = this.itemId.replace("item-", "gauges-text-");
                    unitId = this.itemId.replace("item-", "unit_");
                    // <canvas id="${this.widgetId}"></canvas>
                    //<h2><span id="${valueId}">0</span> <span  id="${unitId}">${this.unit}</span></h2>
                    return `
                            <div id="${this.widgetId}"></div>
                            `;
                case WIDGET_TYPE.MAP:
                    return `<div id="${this.widgetId}"></div>`;
                case WIDGET_TYPE.TABLE:

                    return `<div>
                            <table class="table table-bordered" id="${this.widgetId}" >
                                <thead></thead><tbody></tbody>
                            </table>
                            </div>`;
                case WIDGET_TYPE.TEXTVALUE:
                    return `
                            <h1 style="color:${this.rgb}"><span id="${this.widgetId}">0</span> <span>${this.unit}</span><h1>
                            `;
                case WIDGET_TYPE.TEXTBOX:
                    return `<span id="${this.widgetId}"></span>`;
                default:
                    break;
            }
        };

        this.selectWiContentFull = () => {
            let valueId = "";
            this.fullScreenId = `full-${this.widgetId}`;
            switch (this.type) {
                case WIDGET_TYPE.MUTILINE:
                    return `<canvas id="${this.fullScreenId}"></canvas>`;
                case WIDGET_TYPE.TEXTLINE:
                    valueId = this.itemId.replace("item-", "value_full");
                    return ` <h2 class="text-left"><span id="${valueId}">0</span> ${this.unit}</h2>
                             <canvas id="${this.fullScreenId}"></canvas>
                            `;
                case WIDGET_TYPE.GAUGES:
                    valueId = this.itemId.replace("item-", "gauges-text-full");
                    return `
                            <h2><span id="${valueId}">0</span> <span>${this.unit}</span></h2>
                            <canvas id="${this.fullScreenId}"></canvas>
                            `;
                case WIDGET_TYPE.MAP:
                    return `
                            <div id="${fullScreenId}"></div>
                            `;
                default:
                    break;
            }
        };

        this.createWidget = (gridData = null) => {
            generateId();
            let node = items.pop() || {
                x: 3,
                y: 4,
                width: 6,
                height: 7,
            };

            $(".grid-stack").gridstack(options);
            grid = $(".grid-stack").data("gridstack");

            let layout_widget = "";
            if (this.type !== "TextBox") {
                layout_widget = $("#layout-widget").html();
                if (this.type === WIDGET_TYPE.TEXTVALUE) {
                    node.width = 4;
                    node.height = 4;
                    layout_widget = $("#layout-widget-text-value").html();
                } else if (this.type === WIDGET_TYPE.MUTILINE) {
                    layout_widget = layout_widget.replace(/<<sliderTime>>/g, `slider-${this.itemId}`);
                } else if (this.type.search('static') !== -1) {
                    layout_widget = $("#layout_widget_static").html();
                }
                layout_widget = layout_widget.replace(/div_id/g, this.itemId);
                layout_widget = layout_widget.replace(/widget_id/g, this.widgetId);
                layout_widget = layout_widget.replace("((wi))", this.selectWiContent());
                layout_widget = layout_widget.replace("((title_name))", this.title_name);
                layout_widget = layout_widget.replace("{last_update}", this.lastUpdateId);
                // layout_widget = layout_widget.replace(/<<switch>>/g, `switch-${this.itemId}`);
            } else {
                node.width = 6;
                node.height = 1;
                layout_widget = $("#layout-widget-text").html();
                layout_widget = layout_widget.replace(/div_id/g, this.itemId);
                layout_widget = layout_widget.replace("((wi))", this.selectWiContent());
            }

            node.id = this.itemId;
            let g = null;


            if (this.gridData) {
                g = grid.addWidget(
                    $(layout_widget),
                    this.gridData.x,
                    this.gridData.y,
                    this.gridData.width,
                    this.gridData.height,
                    true, null, null, null, null, node.id
                );
            } else {
                g = grid.addWidget(
                    $(layout_widget),
                    node.x,
                    node.y,
                    node.width,
                    node.height,
                    true, null, null, null, null, node.id
                );
            }

            if (!this.download) {
                g.find('.download').remove();
            }

            // if(this.type === WIDGET_TYPE.TABLE){;
            //     //g.find('.download').show(); 
            // }

            // #set full-screen
            if (this.type !== WIDGET_TYPE.MUTILINE) {
                // g.find('.full-screen > .btn-full-screen').remove();
                g.find('.btn-time-series').remove();
                g.find('.time-series-static').remove();
                g.find('.card-footer').css({
                    height: 'auto'
                });
            } else {
                // this.sliderTime = document.getElementById(`slider-${this.itemId}`);
                // noUiSlider.create(this.sliderTime, {
                //     start: [0, 1440],
                //     connect: true,
                //     // direction: 'rtl',
                //     behaviour: 'tap-drag',
                //     step: 10,
                //     tooltips: [true, true],
                //     range: {
                //         'min': 0,
                //         'max': 1440
                //     },
                //     format: wNumb({
                //         decimals: 2,
                //         mark: ":",
                //         encoder: function (a) {
                //             return aproximateHour(a);
                //         }
                //     }),
                // });
            }

            g.data('_gridstack_data', JSON.stringify(Widget.formateDataSave(this)));

            bindWidgetElement();
        };
    }

    static formateDataSave(data) {
        let formateDate = {
            type: data.type,
            apiName: data.apiName,
            datasources: data.datasources,
            download: data.download ? data.download : false,
            timeInterval: data.timeInterval,
        };

        if (data.type === WIDGET_TYPE.MUTILINE || data.type === WIDGET_TYPE.MUTILINE_STATIC) {
            formateDate.isGroupData = data.isGroupData;
            formateDate.title_name = data.title_name;
            formateDate.datasets = data.datasets;
        } else if (data.type === WIDGET_TYPE.TEXTLINE) {
            formateDate.title_name = data.title_name;
            formateDate.unit = data.unit;
            formateDate.rgb = data.rgb;
        } else if (data.type === WIDGET_TYPE.RADAR) {
            formateDate.datasets = data.datasets;
            formateDate.title_name = data.title_name;
            formateDate.labels = data.labels;
            formateDate.label = data.label;
            formateDate.color = data.color;
        } else if (data.type === WIDGET_TYPE.GAUGES) {
            formateDate.title_name = data.title_name;
            formateDate.opts = data.opts;
            formateDate.limitMin = data.limitMin;
            formateDate.limitMax = data.limitMax;
            formateDate.unit = data.unit;
        } else if (data.type === WIDGET_TYPE.MAP) {
            formateDate.isGroupData = data.isGroupData;
            formateDate.title_name = data.title_name;
        } else if (data.type === WIDGET_TYPE.TABLE) {
            formateDate.title_name = data.title_name;
            formateDate.table = data.table;
        } else if (data.type === WIDGET_TYPE.TEXTVALUE) {
            formateDate.title_name = data.title_name;
            formateDate.unit = data.unit;
            formateDate.rgb = data.rgb;
        } else if (data.type === WIDGET_TYPE.TEXTBOX) {
            formateDate.textbox = data.textbox;
            formateDate.fontsize = data.fontsize;
        }

        return formateDate;

    }
}

class MutiLineStatic extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.chart = null;
        this.datasets = widget.datasets;

        this.static = null;

        this.periodType = "Today";
        this.startDate = null;
        this.endDate = null;


        let options = {
            maintainAspectRatio: false,
            scales: {
                yAxes: [{
                    gridLines: {
                        display: false
                    },
                    ticks: {
                        beginAtZero: true,
                        fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                        fontStyle: "bold",
                    }
                }],
                xAxes: [{

                    gridLines: {
                        display: false
                    },




                }],

            },
            legend: {
                labels: {
                    fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                    fontColor: 'black'
                }
            },
            // pan: {
            //     enabled: true,
            //     mode: "x",
            //     speed: 10,
            //     threshold: 10
            //   },
            //   zoom: {
            //     enabled: true,
            //     drag: false,
            //     mode: "x",
            //     limits: {
            //       max: 10,
            //       min: 0.5
            //     }
            // },
            tooltips: {
                mode: 'nearest',
                intersect: false
            },
            hover: {
                mode: 'nearest',
                intersect: false
            },
        };


        this.createMutiLine = () => {
            let ctx = document.getElementById(this.widgetId);
            let myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: deepCopy(this.datasets)
                },
                options: options,
            });

            this.chart = myChart;
            this.updateStatic();
        };

        let getDataStatic = async () => {
            await $.ajax({
                url: '/js/company/test-aggr.json',
                data: {},
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                success: (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    this.static = res;
                },
                error: (res) => {

                }
            })
        }

        this.updateStatic = async () => {

            await getDataStatic();
            let myChart = this.chart;
            let i = 0;

            myChart.data.labels = [];
            myChart.data.datasets.forEach((dataset) => {
                dataset.data = [];
            });

            console.log(this.static);


            this.static.map(data => {
                //let date = objectPath.get(data, 'date')+"-12-"+"31 10:00:00";
                //console.log(date);
                myChart.data.labels.push(objectPath.get(data, 'date'));
                myChart.data.datasets.forEach((dataset) => {
                    console.log(data.data);
                    dataset.data.push(objectPath.get(data.data, this.datasources[i].val));
                    i++;
                });
                i = 0;

            })

            // if (time_array.length > 0) {
            //     let min = time_array.reduce(function (a, b) {
            //         return a < b ? a : b;
            //     });
            //     let max = time_array.reduce(function (a, b) {
            //         return a > b ? a : b;
            //     });
            //     let hours = diff_hours(max, min);

            //     if (hours >= 1) {
            //         myChart.options.scales.xAxes[0].time.unit = "hour";
            //         if(hours >= 6){
            //             myChart.options.scales.xAxes[0].time.stepSize = 2;
            //         }
            //         else{
            //             myChart.options.scales.xAxes[0].time.stepSize = 1;
            //         }

            //     } else {
            //         myChart.options.scales.xAxes[0].time.unit = "second";
            //     }
            // }

            // switch (this.periodType) {
            //     case PERIOD.TODAY:
            //     case PERIOD.YESTERDAY:
            //     case PERIOD.CURRENT_WEEK:
            //     case PERIOD.WEEK_1:
            //     case PERIOD.WEEK_2:

            //         break;

            //     default:
            //         break;
            // }

            myChart.update();

        };

        this.exportToExcel = () => {
            let data = [];
            this.fullChart.data.labels.map((time, index) => {
                let indexTime = index;
                let dataValue = {};

                dataValue['time'] = time;
                this.fullChart.data.datasets.map(_data => {
                    dataValue[_data.label] = _data.data[indexTime];
                });
                data.push(dataValue);
            })
            const Json2csvParser = require('json2csv').Parser;
            const fields = Object.keys(data[0]);
            const opts = {
                fields
            };

            // try {
            //     const parser = new Json2csvParser(opts);
            //     const csv = parser.parse(data);
            //     let blob = new Blob([csv], {type: "text/plain;charset=utf-8"});
            //     FileSaver.saveAs(blob, `report.csv`);
            // } catch (err) {
            //     console.error(err);
            // }

            try {

                json2excel({
                    data,
                    name: 'report',
                    formateDate: 'yyyy/mm/dd HH:MM:ss'
                });

            } catch (e) {
                console.error('export error');
            }
        }

        this.createWidget();
        this.createMutiLine();

    }
}



class MutiLine extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.axis_x = widget.axis_x;
        this.axis_y = widget.axis_y;
        this.isGroupData = widget.isGroupData;
        this.fullScreenId = widget.fullScreenId;
        this.chart = null;
        this.datasets = widget.datasets;
        this.dateTimeSeries = null;
        this.firstLoadData = true;

        this.periodType = "Today";
        this.startDate = null;
        this.endDate = null;

        this.isWidgetRealTime = true;


        let time_array = [];

        let options = {
            maintainAspectRatio: false,
            scales: {

                yAxes: [{
                    scaleLabel: {
                        display: true,
                        labelString: 'y-axis'
                    },
                    gridLines: {
                        display: false
                    },
                    ticks: {
                        beginAtZero: true,
                        fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                        fontStyle: "bold",
                    }
                }],
                xAxes: [{
                    // type: 'realtime',
                    type: 'time',
                    scaleLabel: {
                        display: true,
                        labelString: 'x-axis'
                    },
                    // time: {
                    //     displayFormats: {

                    //        'minute': 'h:mm a',
                    //        'hour': 'hA',
                    //     }
                    // },
                    distribution: 'series',
                    // time: {
                    //     unit: "hour",
                    //     stepSize: 1,
                    // },
                    // time: {
                    //     parser: 'YYYY-MM-DD HH:mm:ss',
                    //     unit: 'day',
                    //     displayFormats: {
                    //        day: 'ddd'
                    //     },
                    //     min: '2017-10-02 18:43:53',
                    //     max: '2017-10-09 18:43:53'
                    // },
                    gridLines: {
                        display: false
                    },
                    // realtime: { // per-axis options
                    //     duration: 20000, // data in the past 20000 ms will be displayed
                    //     delay: 3000, // delay of 1000 ms, so upcoming values are known before plotting a line
                    //     pause: false, // chart is not paused
                    //     ttl: undefined // data will be automatically deleted as it disappears off the chart
                    // },
                    ticks: {
                        fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                        fontStyle: "bold",
                        autoSkip: true,
                        // autoSkipPadding: 30,
                        maxRotation: 0,
                        // padding: 20,
                        //maxTicksLimit:3,
                        // source: 'auto'
                        //autoSkip : true,

                        callback: function (tick, index, array) {
                            return (index % 3) ? "" : tick;
                        }
                    },

                }],

            },
            // plugins: {
            //     streaming: { // per-chart option
            //         frameRate: 30 // chart is drawn 30 times every second
            //     }
            // },
            legend: {
                labels: {
                    fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                    fontColor: 'black'
                }
            },
            tooltips: {
                mode: 'nearest',
                intersect: false
            },
            hover: {
                mode: 'nearest',
                intersect: false
            },
        };

        let optionsTimeSeries = {
            maintainAspectRatio: false,
            scales: {
                yAxes: [{
                    gridLines: {
                        display: false
                    },
                    scaleLabel: {
                        display: true,
                        labelString: 'y-axis'
                    },
                    ticks: {
                        beginAtZero: true,
                        fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                        fontStyle: "bold",
                    }
                }],
                xAxes: [{
                    type: 'time',
                    scaleLabel: {
                        display: true,
                        labelString: 'x-axis'
                    },
                    // distribution: 'series',
                    gridLines: {
                        display: false
                    },
                    ticks: {
                        fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                        fontStyle: "bold",
                        // callback: function(tickValue, index, ticks) {
                        //     console.log(ticks);
                        // }
                    },

                }],

            },
            pan: {
                enabled: true,
                mode: "x",
                speed: 10,
                threshold: 10
            },
            zoom: {
                enabled: true,
                drag: false,
                mode: "x",
                limits: {
                    max: 10,
                    min: 0.5
                }
            },
            legend: {
                labels: {
                    fontFamily: "'Poppins', 'Kanit', 'sans-serif'",
                    fontColor: 'black'
                }
            },
            tooltips: {
                mode: 'nearest',
                intersect: false
            },
            hover: {
                mode: 'nearest',
                intersect: false
            },
        };


        this.createMutiLine = () => {
            let ctx = document.getElementById(this.widgetId);
            //console.log(this.datasets);
            let myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: deepCopy(this.datasets)
                },
                options: options,
                // plugins: [{
                //     beforeInit: function(chart) {
                //        var time = chart.options.scales.xAxes[0].time, // 'time' object reference
                //           timeDiff = moment(time.max).diff(moment(time.min), 'd'); // difference (in days) between min and max date
                //        // populate 'labels' array
                //        // (create a date string for each date between min and max, inclusive)
                //        for (var i = 0; i <= timeDiff; i++) {
                //           var _label = moment(time.min).add(i, 'd').format('YYYY-MM-DD HH:mm:ss');
                //           console.log(_label);
                //           chart.data.labels.push(_label);
                //        }
                //     }
                //  }]
            });
            //myChart.config.options.scales.xAxes[0].realtime.onRefresh = this.updateData(myChart);
            // scaleLabel: {
            //     display: true,
            //     labelString: 'x-axis'
            // },
            myChart.config.options.scales.xAxes[0].scaleLabel.labelString = this.axis_x;
            myChart.config.options.scales.yAxes[0].scaleLabel.labelString = this.axis_y;
            this.chart = myChart;
            this.createFullWidget();
            // if(Datasource.getDatasources() != null){
            //     this.updateFirstData();
            // }
        };

        this.updateFirstData = async () => {
            let myChart = this.chart;
            try {
                if (!this.isGroupData) {

                    let timeLast = null;
                    for (let i = 0; i < myChart.data.datasets.length; i++) {
                        let datasource_daily = await Datasource.getValueFirstData(this.datasources[i]);
                        let path = this.datasources[i].val;
                        datasource_daily.map(_data => {
                            myChart.data.datasets[i].data.push({
                                x: new Date(objectPath.get(_data, 'newDate')),
                                y: objectPath.get(_data, path),
                            })
                            timeLast = new Date(objectPath.get(_data, 'newDate'));
                        });
                    }

                    this.updateLastUpdate(timeLast);




                    // myChart.data.datasets.map(dataset => {
                    //     let path = this.datasources[i].val;
                    //     datasource_daily.map(_data => {
                    //         // dataset.data.push(objectPath.get(_data, path));


                    //         dataset.data.push({
                    //             x: new Date(objectPath.get(_data, 'date')),
                    //             y: objectPath.get(_data, path),
                    //         })

                    //         // if (i === 0) {
                    //         //     //time_array.push(new Date(objectPath.get(_data, 'date')));
                    //         //     let date = new Date(objectPath.get(_data,'date'));
                    //         //     myChart.data.labels.push(date);
                    //         // }
                    //     });
                    //     i++;
                    // });

                    this.firstLoadData = false;
                } else {
                    dataset.data.push(objectPath.get(Datasource.getDatasources(), this.datasources.replace('[]', i)));
                }
                myChart.update();
            } catch (e) {
                //console.log(e);
            }

        }

        this.updateSocket = (service_id, type) => {

            let myChart = this.chart;
            let d = new Date();
            let apiUpdate = [];
            let timeLast = null;

            this.datasources.map((_data, index) => {
                if (_data.id === service_id && _data.type === type) {
                    apiUpdate.push(index);
                }
            });

            //myChart.data.labels.push(d.toLocaleTimeString());
            //let date = Date.now();
            //myChart.data.labels.push(d);
            apiUpdate.map(_i => {
                if (myChart.data.datasets[_i].data.length > 10) {
                    myChart.data.datasets[_i].data.splice(0, 1);
                }

                timeLast = Datasource.getValueRealtime(this.datasources[_i], 'newDate');
                myChart.data.datasets[_i].data.push({
                    x: new Date(timeLast),
                    y: Datasource.getValueRealtime(this.datasources[_i])
                })
            })
            if (myChart.data.labels.length > 10) myChart.data.labels.splice(0, 1);
            myChart.update();

            this.updateLastUpdate(timeLast);
        }

        this.updateData = () => {
            let myChart = this.chart;
            let d = new Date();
            time_array.push(d);
            //myChart.data.labels.push(d.toLocaleTimeString());
            //let date = Date.now();
            let timeLast = null;
            let i = 0;
            myChart.data.labels.push(d);
            myChart.data.datasets.forEach((dataset) => {
                if (dataset.data.length > 10) {
                    dataset.data.splice(0, 1);
                }

                if (!this.isGroupData) {

                    //dataset.data.push(Datasource.getValueRealtime(this.datasources[i]))
                    timeLast = Datasource.getValueRealtime(this.datasources[_i], 'newDate');
                    dataset.data.push({
                        x: new Date(timeLast),
                        y: Datasource.getValueRealtime(this.datasources[i])
                    });

                    dataset.data.splice(0, 1);
                } else {
                    dataset.data.push(Datasource.getValueRealtime(this.datasources[i], i));
                }
                i++;
            });




            // time_array.splice(0, 1);
            // if (time_array.length > 0) {
            //     let min = time_array.reduce(function (a, b) {
            //         return a < b ? a : b;
            //     });
            //     let max = time_array.reduce(function (a, b) {
            //         return a > b ? a : b;
            //     });
            //     let hours = diff_hours(max, min);
            //     if (hours >= 1) {
            //         myChart.options.scales.xAxes[0].time.unit = "hour";
            //         if(hours >= 6){
            //             myChart.options.scales.xAxes[0].time.stepSize = 2;
            //         }
            //         else{
            //             myChart.options.scales.xAxes[0].time.stepSize = 1;
            //         }

            //     } else {
            //         myChart.options.scales.xAxes[0].time.unit = "second";
            //     }
            // }
            if (myChart.data.labels.length > 10) myChart.data.labels.splice(0, 1);
            myChart.update();
            this.updateLastUpdate(timeLast);
        };

        this.createFullWidget = () => {
            let ctx = document.getElementById(this.timeSeries);
            // state.selectItemId = this.itemId;
            let myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: deepCopy(this.datasets)
                },
                options: optionsTimeSeries
            });


            myChart.config.options.scales.xAxes[0].scaleLabel.labelString = this.axis_x;
            myChart.config.options.scales.yAxes[0].scaleLabel.labelString = this.axis_y;
            this.fullChart = myChart;
        };

        let getDataTimeSeries = async () => {
            await $.ajax({
                url: '/js/company/test-api-static.json',
                data: {},
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                success: (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    this.dateTimeSeries = res;
                },
                error: (res) => {

                }
            })
        }

        this.updatePropWidget = () => {
            let data_line = [];
            let data_widget = null;
            let el = $("#" + this.editModalId);
            let length_label = el.find(elements.DOMString.class.labelChartLine).length;
            let value_datasource = [];

            el.find(elements.DOMString.class.valueDatasource).each(function () {
                value_datasource.push({
                    id: $(this).attr("service_id"),
                    type: $(this).attr("label"),
                    val: $(this).val()
                });
            });




            for (let i = 0; i < length_label; i++) {
                let label_y = el.find(elements.DOMString.class.labelChartLine);
                let rgb = el.find(elements.DOMString.class.colorChartLine);
                let rgba = 'rgba(255,255,255,0.0)';
                let data = null;
                data = {
                    label: $(label_y[i]).val(),
                    backgroundColor: rgba,
                    borderColor: $(rgb[i]).val(),
                    lineTension: 0,
                    pointRadius: 0,
                    borderWidth: 2
                };
                data_line.push(data);
            }

            data_widget = {
                datasources: value_datasource,
                datasets: [...data_line],
            };

            console.log(value_datasource);

            let myChart = this.chart;
            myChart.data.datasets = deepCopy(data_widget.datasets)
            this.datasources = value_datasource;

            this.axis_x = el.find(".axis_x").val();
            this.axis_y = el.find(".axis_y").val();
            myChart.config.options.scales.xAxes[0].scaleLabel.labelString = this.axis_x;
            myChart.config.options.scales.yAxes[0].scaleLabel.labelString = this.axis_y;

            let fullChart = this.fullChart;
            fullChart.data.datasets = deepCopy(data_widget.datasets)
            fullChart.config.options.scales.xAxes[0].scaleLabel.labelString = this.axis_x;
            fullChart.config.options.scales.yAxes[0].scaleLabel.labelString = this.axis_y;


            this.sendUpdateSocket();
            this.datasets = deepCopy(data_widget.datasets);

            myChart.update();
            fullChart.update();
            this.updateFirstData();
        }

        this.updateTimeSeries = async () => {

            await getDataTimeSeries();
            let myChart = this.fullChart;
            let i = 0;

            myChart.data.labels = [];
            myChart.data.datasets.forEach((dataset) => {
                dataset.data = [];
            });

            let time_array = [];

            this.dateTimeSeries.map(data => {
                //myChart.data.labels.push(new Date(objectPath.get(data, 'date')));
                //time_array.push(new Date(objectPath.get(data, 'date')));
                myChart.data.datasets.forEach((dataset) => {
                    if (!this.isGroupData) {
                        //dataset.data.push(objectPath.get(data, this.datasources[i].val));
                        dataset.data.push({
                            x: new Date(objectPath.get(data, 'date')),
                            y: objectPath.get(data, this.datasources[i].val)
                        })
                    } else {
                        // let valueIn = this.datasources.split('.');
                        // valueIn.splice(0, 1);
                        // valueIn = valueIn.join('.');
                        // valueIn = valueIn.replace('[]', i);
                        // dataset.data.push(objectPath.get(data, valueIn));
                    }
                    i++;
                });
                i = 0;

            })

            // if (time_array.length > 0) {
            //     let min = time_array.reduce(function (a, b) {
            //         return a < b ? a : b;
            //     });
            //     let max = time_array.reduce(function (a, b) {
            //         return a > b ? a : b;
            //     });
            //     let hours = diff_hours(max, min);

            //     if (hours >= 1) {
            //         myChart.options.scales.xAxes[0].time.unit = "hour";
            //         if(hours >= 6){
            //             myChart.options.scales.xAxes[0].time.stepSize = 2;
            //         }
            //         else{
            //             myChart.options.scales.xAxes[0].time.stepSize = 1;
            //         }

            //     } else {
            //         myChart.options.scales.xAxes[0].time.unit = "second";
            //     }
            // }

            // switch (this.periodType) {
            //     case PERIOD.TODAY:
            //     case PERIOD.YESTERDAY:
            //     case PERIOD.CURRENT_WEEK:
            //     case PERIOD.WEEK_1:
            //     case PERIOD.WEEK_2:

            //         break;

            //     default:
            //         break;
            // }

            myChart.update();

        };

        this.exportToExcel = () => {
            let dataExcel = [];
            let chart = null;
            if (this.isWidgetRealTime) {
                chart = this.chart;
            } else {
                chart = this.fullChart;
            }


            chart.data.datasets.map(_data => {
                let {
                    label,
                    data
                } = _data;
                data.map(_dataChart => {
                    let dataValue = {};
                    dataValue['label'] = label;
                    dataValue[chart.config.options.scales.xAxes[0].scaleLabel.labelString] = _dataChart.x;
                    dataValue[chart.config.options.scales.yAxes[0].scaleLabel.labelString] = _dataChart.y;
                    dataExcel.push(dataValue);
                });


            });


            // chart.data.labels.map((time, index) => {
            //     let indexTime = index;
            //     let dataValue = {};

            //     dataValue['time'] = time;
            //     this.fullChart.data.datasets.map(_data => {
            //         dataValue[_data.label] = _data.data[indexTime];
            //     });
            //     data.push(dataValue);
            // })

            //console.log(data);
            let data = dataExcel

            try {

                json2excel({
                    data,
                    name: 'report',
                    formateDate: 'yyyy/mm/dd HH:MM:ss'
                });

            } catch (e) {
                console.error('export error');
            }
        }




        if (this.type === WIDGET_TYPE.MUTILINE) {
            this.createWidget();
            this.createMutiLine();
        }

    }
}

class ChartTextLine extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.fullScreenId = widget.fullScreenId;
        this.unit = widget.unit;
        this.rgb = widget.rgb;

        const optionChartLineNotLable = {
            maintainAspectRatio: false,
            responsive: true,
            scales: {
                yAxes: [{
                    display: false
                }],
                xAxes: [{
                    display: false
                }]
            },
            legend: {
                display: false
            },
            elements: {
                point: {
                    radius: 0
                },
                line: {
                    tension: 0
                }
            },
            layout: {
                padding: {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 30
                }
            },
            stepsize: 100
        };


        this.createTextLine = () => {
            let ctx = document.getElementById(this.widgetId);
            let myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '',
                        data: [],
                        backgroundColor: [
                            'rgba(255, 255, 255, 0)',
                        ],
                        borderColor: [
                            this.rgb
                        ],
                        borderWidth: 2
                    }]
                },
                options: optionChartLineNotLable
            });
            this.chart = myChart;
            this.updateData();
            return myChart;
        };

        this.createFullWidget = () => {
            let ctx = document.getElementById(this.fullScreenId);
            let myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '',
                        data: [],
                        backgroundColor: [
                            'rgba(255, 255, 255, 0)',
                        ],
                        borderColor: [
                            this.rgb
                        ],
                        borderWidth: 2
                    }]
                },
                options: optionChartLineNotLable
            });
        };

        // this.updateSocket = (apiName) => {
        //     let value = this.widgetId;
        //     value = value.replace(this.type.toLowerCase(), "value");
        //     let myChart = this.chart;
        //     let d = new Date();
        //     let apiUpdate = [];

        //     this.datasource.map((_data, index) => {
        //         if (_data.split('.')[0] === apiName) {
        //             apiUpdate.push(index);
        //         }
        //     });


        //     myChart.data.labels.push(d);
        //     apiUpdate.map(_i => {

        //         if (myChart.data.datasets[_i].data.length > 10) {
        //             myChart.data.datasets[_i].data.splice(0, 1);
        //         }
        //         let data = Datasource.getValueRealtime(this.datasource[_i]);
        //         myChart.data.datasets[_i].data.push(data);
        //         $("#" + value).html(data);


        //     })
        //     if (myChart.data.labels.length > 10) myChart.data.labels.splice(0, 1);
        //     myChart.update();
        //     this.updateLastUpdate();
        // }

        this.updatePropWidget = () => {
            let el = $("#" + this.editModalId);

            let rgb = el.find(elements.DOMString.id.rgb).val();
            let elValueDatasource = el.find(elements.DOMString.class.valueDatasource);

            let value_datasource = [{
                id: elValueDatasource.attr('service_id'),
                type: elValueDatasource.attr('label'),
                val: elValueDatasource.val()
            }];

            let myChart = this.chart;
            myChart.data.datasets[0].borderColor = [];
            myChart.data.datasets[0].data = [];
            myChart.data.datasets[0].borderColor.push(rgb)
            this.datasources = value_datasource
            this.sendUpdateSocket();
            myChart.update();
            this.updateData();
        };

        this.updateData = () => {
            let value = this.widgetId;
            value = value.replace(this.type.toLowerCase(), "value");
            let timeLast = null
            let myChart = this.chart;
            //let data = Math.floor(100 + Math.random() * 900);
            let d = new Date();
            myChart.data.labels.push(d.toLocaleTimeString());
            myChart.data.datasets.forEach((dataset) => {
                if (dataset.data.length > 10) {
                    dataset.data.splice(0, 1);
                    //myChart.data.labels.splice(0, 1);
                }
                timeLast = Datasource.getValueRealtime(this.datasources[0],'newDate');
                let data = Datasource.getValueRealtime(this.datasources[0]);

                dataset.data.push(data);
                $("#" + value).html(data);
            });

            if (myChart.data.labels.length > 10) myChart.data.labels.splice(0, 1);

            myChart.update();
            this.updateLastUpdate(timeLast);
        };

        this.liveData = () => {
            let value = this.widgetId;
            value = value.replace(this.type, "value_");
            let myChart = this.chart;
            let d = new Date();
            myChart.data.labels.push(d.toLocaleTimeString());
            myChart.data.datasets.forEach((dataset) => {
                if (dataset.data.length > 10) {
                    dataset.data.splice(0, 1);
                    //myChart.data.labels.splice(0, 1);
                }
                let data = dataset.data[dataset.data.length - 1];
                dataset.data.push(data);
            });

            if (myChart.data.labels.length > 10) myChart.data.labels.splice(0, 1);

            myChart.update();
            //this.updateLastUpdate();
        };

        if (this.type === WIDGET_TYPE.TEXTLINE) {
            this.createWidget();
            this.createTextLine();
        }
    }
}

class Radar extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);

        this.datasets = widget.datasets;
        this.labels = widget.labels;
        this.label = widget.label;
        this.color = widget.color;
        this.radar = null;

        this.createWidget();

        let config = {
            type: 'radar',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                maintainAspectRatio: false,
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                },
                scale: {
                    ticks: {
                        beginAtZero: true
                    }
                }
            }
        };

        this.createRadar = () => {
            let ctx = document.getElementById(this.widgetId);
            let myRadarChart = new Chart(ctx, config);
            let i = 0;
            myRadarChart.data.labels = this.labels;
            myRadarChart.data.datasets = deepCopy(this.datasets);
            myRadarChart.data.datasets.forEach((dataset) => {
                dataset.label = this.label[i];
                dataset.backgroundColor = convertHex(this.color[i], 20);
                dataset.borderColor = this.color[i];
                dataset.pointBackgroundColor = this.color[i];
                dataset.data = [];
                i++;
            });
            myRadarChart.update();
            this.radar = myRadarChart;
            this.updateData();
        };

        this.updateData = () => {
            let i = 0;

            let timeLast = null;
            this.radar.data.datasets.forEach((dataset) => {
                dataset.data = [];
                this.radar.data.labels.map(k => {
                    timeLast = Datasource.getValueRealtime(this.datasources[i],'newDate');
                    let data = Datasource.getValueRealtime(this.datasources[i]);
                    dataset.data.push(data);
                    i++;
                });
            });
            this.radar.update();
            this.updateLastUpdate(timeLast);
        };

        this.updatePropWidget = () => {
            let datasets = [];
            let labels = [];
            let label = [];
            let value_datasource = [];
            let color = [];

            state.editModalIdSelect.find(elements.DOMString.class.radarLabel).each(function () {
                labels.push($(this).val());
            });

            state.editModalIdSelect.find(elements.DOMString.class.formRadarValue).each(function () {
                datasets.push({});
                label.push($(this).find(elements.DOMString.class.labelRadar).val());

                $(this).find(elements.DOMString.class.valueDatasource).each(function () {
                    value_datasource.push({
                        id: $(this).attr('service_id'),
                        type: $(this).attr('label'),
                        val: $(this).val(),
                    });
                });

                $(this).find(elements.DOMString.class.radarColor).each(function () {
                    color.push($(this).val());
                });

            });

            this.datasources = value_datasource;
            this.labels = labels;
            this.label = label;
            this.color = color;
            this.datasets = datasets;

            let i = 0;
            this.radar.data.labels = this.labels;
            this.radar.data.datasets = deepCopy(datasets);
            this.radar.data.datasets.forEach((dataset) => {
                dataset.label = this.label[i];
                dataset.backgroundColor = convertHex(this.color[i], 20);
                dataset.borderColor = this.color[i];
                dataset.pointBackgroundColor = this.color[i];
                dataset.data = [];
                i++;
            });
            this.radar.update()
            this.updateData();

        }

        this.exportToExcel = () => {
            let dataExcel = [];
            let chart = this.radar;

            console.log(chart.data.datasets);
            let i = 0;
            chart.data.datasets.map(_data => {
                let {
                    data,
                    label
                } = _data;
                let dataValue = {};
                dataValue['label'] = label;
                data.map(_dataChart => {
                    dataValue[this.labels[i]] = _dataChart
                    i++;
                });
                i = 0;
                dataExcel.push(dataValue);


            });


            let data = dataExcel

            try {

                json2excel({
                    data,
                    name: 'report',
                    formateDate: 'yyyy/mm/dd HH:MM:ss'
                });

            } catch (e) {
                console.error('export error');
            }
        }

        this.createRadar();
    }
}

class RadarEx {
    constructor() {

        let colorEx = {
            0: 'rgb(255, 99, 132)',
            1: 'rgb(255, 159, 64)',
            2: 'rgb(255, 205, 86)',
            3: 'rgb(75, 192, 192)',
            4: 'rgb(54, 162, 235)',
            5: 'rgb(153, 102, 255)',
        };

        let config = {
            type: 'radar',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                },
                scale: {
                    ticks: {
                        beginAtZero: true
                    }
                }
            }
        };

        this.createRadarExample = () => {
            if (radarEx === null) {
                let ctx = document.getElementById("example_radar");
                let myRadarChart = new Chart(ctx, config);
                radarEx = myRadarChart;
                this.updateRadarExample();
            }
        };

        let removeRaderExample = () => {
            radarEx.data.labels = [];
            radarEx.data.datasets = [];
        };

        this.updateRadarExample = () => {
            let lables = [];
            let lable = [];
            let data = [];
            let colorInput = [];
            let color = Chart.helpers.color;


            $(".radar-labels:visible").each(function () {
                lables.push($(this).val());
                data.push(getRandomInt(0, 50));
            });


            removeRaderExample();

            $(".label-radar:visible").each(function () {
                lable.push($(this).val());
                radarEx.data.datasets.push({});
            });

            $(".radar-color").each(function () {
                colorInput.push($(this).val());
            });

            // dataset.backgroundColor = color(colorEx[colorIndex]).alpha(0.2).rgbString();
            // dataset.borderColor = colorEx[colorIndex];
            // dataset.pointBackgroundColor = colorEx[colorIndex];

            let i = 0;
            radarEx.data.labels = lables;
            radarEx.data.datasets.forEach((dataset) => {
                dataset.label = lable[i];
                dataset.backgroundColor = convertHex(colorInput[i], 20);
                dataset.borderColor = colorInput[i];
                dataset.pointBackgroundColor = colorInput[i];
                dataset.data = data;
                data = data.map(n => {
                    return n + getRandomInt(0, 10);
                });
                i++;
            });
            radarEx.update();
        };
    }
}

class Gauges extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.fullScreenId = widget.fullScreenId;
        this.textId = widget.textId;
        this.gaugeWidget = null;
        this.opts = widget.opts;
        this.limitMax = widget.limitMax ? widget.limitMax : 100;
        this.limitMin = widget.limitMin ? widget.limitMin : 0;
        this.unit = widget.unit;

        this.createWidget();

        this.createGages = () => {
            this.gaugeWidget = new JustGage({
                id: this.widgetId,
                value: 0,
                min: this.limitMin,
                max: this.limitMax,
                symbol: ' ' + this.unit,
                relativeGaugeSize: true,
                titlePosition: "below"
            });
            $("#" + this.widgetId).height($("#" + this.widgetId).height() - 5);
            $("#" + this.widgetId).addClass('container');


            this.updateData();

            // let target = document.getElementById(this.widgetId); // your canvas element
            // let gauge = new Gauge(target).setOptions(this.opts); // create sexy gauge!
            // gauge.maxValue = this.limitMax; // set max gauge value
            // gauge.setMinValue(0);  // Prefer setter over gauge.minValue = 0
            // gauge.animationSpeed = 32; // set animation speed (32 is default value)
            // gauge.set(0); // set actual value
            // this.gaugeWidget = gauge;
            // this.updateData();
        };

        // this.updateSocket = (apiName) => {

        //     if(apiName === this.datasource[0].split('.')[0]){
        //         let data = Datasource.getValueRealtime(this.datasource[0]);

        //         this.gaugeWidget.refresh(data ? data : 0);
        //         this.updateLastUpdate();
        //     }
        // };

        this.updateData = () => {
            //getRandomInt(Number(this.limitMin), Number(this.limitMax))

            let data = Datasource.getValueRealtime(this.datasources[0]);
            this.gaugeWidget.refresh(data ? data : 0);
            let timeLast = Datasource.getValueRealtime(this.datasources[0],'newDate');
            this.updateLastUpdate(timeLast);

            // let data = Math.floor(Math.random() * (100 - 1));
            // $("#" + this.textId).html(data);
            // this.gaugeWidget.set(data);
            // this.updateLastUpdate();


        };

        this.createGages();
    }
}

class Map extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.isGroupData = widget.isGroupData;
        this.markers = null;
        this.start = widget.start;
        this.end = widget.end;
        this.fullScreenId = widget.fullScreenId;
        this.myMap = null;

        this.createWidget();

        this.createMap = () => {
            let mymap;
            let mapid = this.widgetId;
            let height = $("#" + this.itemId).height() - 100;
            $('#' + mapid).css('height', height);
            $('#' + mapid).css('width', 'auto');

            mymap = L.map(mapid, {
                dragging: true,
                zoomControl: true,
                scrollWheelZoom: false,
                zoomAnimation: false,
                renderer: L.canvas(),
            });


            $.getJSON('https://raw.githubusercontent.com/apisit/thailand.json/master/thailand.json').then(function (geoJSON) {
                var osm = new L.TileLayer.BoundaryCanvas("https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
                    boundary: geoJSON,
                    minZoom: 5,
                    maxZoom: 9,
                    attribution: '&copy; Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ'
                });
                mymap.addLayer(osm);
                var ukLayer = L.geoJSON(geoJSON);
                mymap.fitBounds(ukLayer.getBounds());
            }).then(() => {

            });

            function disableGrid() {
                let grid = $('.grid-stack').data('gridstack');
                grid.enableMove(false);
            }

            function enableGrid() {
                let grid = $('.grid-stack').data('gridstack');
                grid.enableMove(true);
            }

            $('.grid-stack').on('change', function (e, items) {
                if (mymap != null) {
                    mymap.invalidateSize(true);
                }
            });

            // mymap.on('mousemove', disableGrid);
            // mymap.on('mouseout', enableGrid);

            this.myMap = mymap;
            //this.updateData();
        };

        this.updateData = () => {
            this.myMap.invalidateSize(true);
            if (this.markers) {
                this.markers.clearLayers();
            }
            let heat = [];
            if (!this.isGroupData) {
                this.markers = L.layerGroup().addTo(this.myMap);
                this.datasources.map(data => {
                    let datasource = Datasource.getDatasourceRealtime(data.id, data.type);
                    let lat = objectPath.get(datasource, data.latitude) //objectPath.get(Datasource.getDatasources(), data.latitude);
                    let lon = objectPath.get(datasource, data.longitude) //objectPath.get(Datasource.getDatasources(), data.longitude);
                    let label = data.label;
                    let value = objectPath.get(datasource, data.value) //objectPath.get(Datasource.getDatasources(), data.value);

                    L.marker([lat, lon]).addTo(this.markers).bindPopup(`${label} : ${value}`);



                    // heat.push([lat, lon, value  / 100]);


                    // L.heatLayer(heat, {
                    //     radius: 75,
                    // }).addTo(this.markers);

                });

            } else {
                let datasource = objectPath.get(Datasource.getDatasources(), this.datasources.groupData);
                for (let i in datasource) {
                    let lat = objectPath.get(Datasource.getDatasources(), this.datasources.latitude.replace('[]', i));
                    let lon = objectPath.get(Datasource.getDatasources(), this.datasources.longitude.replace('[]', i));
                    let label = objectPath.get(Datasource.getDatasources(), this.datasources.label.replace('[]', i));
                    let value = objectPath.get(Datasource.getDatasources(), this.datasources.value.replace('[]', i));
                    L.marker([lat, lon]).addTo(this.myMap).bindPopup(`${label} : ${value}`);
                    heat.push([lat, lon, value / 100]);

                }
                // L.heatLayer(heat, {
                //     radius: 75
                // }).addTo(this.myMap);
            }

            // $.ajax({
            //     dataType: "json",
            //     url: '/js/company/test-api.json',
            //     async: false,
            //     success: function (data) {
            //         var heat = [];
            //         var WeatherForecasts = data.WeatherForecasts;
            //         for (let i in WeatherForecasts) {
            //             L.marker([WeatherForecasts[i].location.lat, WeatherForecasts[i].location.lon]).addTo(mymap).bindPopup(WeatherForecasts[i].location.province + " " + "อ ุณหภูมิที่ระดับพื้นผิว : " + WeatherForecasts[i].forecasts[1].data.tc + " °C");
            //             heat.push([WeatherForecasts[i].location.lat, WeatherForecasts[i].location.lon, WeatherForecasts[i].forecasts[1].data.tc / 100]);

            //         }
            //         L.heatLayer(heat, {
            //             radius: 75
            //         }).addTo(mymap);
            //     }
            // });
            this.updateLastUpdate();
        }

        this.updatePropWidget = () => {
            let datasource = [];

            state.editModalIdSelect.find(elements.DOMString.class.valueOfMap).each(function () {
                let lat = $(this).find(".latitude").val();
                let long = $(this).find(".longitude").val();
                let value = $(this).find(".value-map").val();
                let label = $(this).find(".label-map").val();

                datasource.push({
                    id: $(this).find(".latitude").attr('service_id'),
                    type: $(this).find(".latitude").attr('label'),
                    latitude: lat,
                    longitude: long,
                    value: value,
                    label: label
                });


            })
            this.datasources = datasource;
            this.updateData();
        }

        this.createFullWidget = () => {
            let mymap;
            let mapid = this.fullScreenId;
            let height = "450px";
            $('#' + mapid).css('height', height);
            $('#' + mapid).css('width', 'auto');

            mymap = L.map(mapid, {
                dragging: true,
                zoomControl: true,
                scrollWheelZoom: false,
                zoomAnimation: false,
            });

            $.getJSON('https://raw.githubusercontent.com/apisit/thailand.json/master/thailand.json').then(function (geoJSON) {
                var osm = new L.TileLayer.BoundaryCanvas("https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}", {
                    boundary: geoJSON,
                    minZoom: 5,
                    maxZoom: 9,
                    attribution: '&copy; Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ'
                });
                mymap.addLayer(osm);
                var ukLayer = L.geoJSON(geoJSON);
                mymap.fitBounds(ukLayer.getBounds());


            }).then(() => {
                setTimeout(() => {
                    mymap.invalidateSize(true);
                    $.ajax({
                        dataType: "json",
                        url: '/js/company/test-api.json',
                        headers: {
                            authorization: 'bearer ' + getCookie('token'),
                        },
                        async: false,
                        success: function (data) {
                            var heat = [];
                            var WeatherForecasts = data.WeatherForecasts;
                            for (let i in WeatherForecasts) {
                                L.marker([WeatherForecasts[i].location.lat, WeatherForecasts[i].location.lon]).addTo(mymap).bindPopup(WeatherForecasts[i].location.province + " " + "อ ุณหภูมิที่ระดับพื้นผิว : " + WeatherForecasts[i].forecasts[1].data.tc + " °C");
                                heat.push([WeatherForecasts[i].location.lat, WeatherForecasts[i].location.lon, WeatherForecasts[i].forecasts[1].data.tc / 100]);

                            }
                            L.heatLayer(heat, {
                                radius: 75
                            }).addTo(mymap);
                        }
                    });

                }, 1000);
            });
        };

        this.exportToExcel = () => {
            let data = [];
            this.datasources.map(_data => {
                let datasource = Datasource.getDatasourceRealtime(_data.id, _data.type);
                let dataExcel = {};
                dataExcel["latitude"] = objectPath.get(datasource, _data.latitude) 
                dataExcel["longitude"] = objectPath.get(datasource, _data.longitude)
                dataExcel["label"] = _data.label;
                dataExcel["value"] = objectPath.get(datasource, _data.value)
                data.push(dataExcel)
            });

            
            try {
                json2excel({
                    data,
                    name: 'report',
                    formateDate: 'yyyy/mm/dd HH:MM:ss'
                });

            } catch (e) {
                console.error('export error');
            }
        }

        this.createMap();
    }
}

class Table extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.table = widget.table;
        this.static = null;

        this.createWidget();

        this.createTable = () => {
            this.el = $('#' + this.widgetId);
            this.el.find('thead').append('<tr></tr>');
            for (let i = 0; i < this.table.col_labels.length; i++) {
                this.el.find('thead tr').append(`<th>${this.table.col_labels[i]}</th>`);
            };

            for (let i = 0; i < this.table.rows.length; i++) {
                let rows = '';
                for (let j = 0; j < this.table.col_labels.length; j++) {
                    if (j === 0) {
                        rows += `<td>${this.table.rows[i].label}</td>`;
                    } else {
                        rows += `<td></td>`;
                    }
                }
                this.el.find('tbody').append(`<tr>${rows}</tr>`);
            };

            $('#' + this.widgetId).parent().addClass('table-responsive');
            $('#' + this.widgetId).css({
                "width": "100%",
                "overflow-x": "auto",
                "overflow-y": "auto"
            });

            this.updateData();
        }


        this.updateData = () => {
            let timeLast = null
            try {
                let i = 0;
                let rows = this.table.rows;
                this.el.find('tbody tr').each(function () {
                    let j = 0;
                    $(this).find('td').not(':first').each(function () {
                        timeLast = Datasource.getValueRealtime(rows[i].data[j],'newDate');
                        let data = Datasource.getValueRealtime(rows[i].data[j]);
                        $(this).html(data);
                        j++;
                    });
                    i++;
                });
                this.updateLastUpdate(timeLast);
            } catch (error) {

            }
        }

        this.updatePropWidget = (tableEx) => {
            this.table = tableEx.getValue();
            this.datasources = tableEx.getValue().datasources;
            $('#' + this.widgetId).find('thead').empty();
            $('#' + this.widgetId).find('tbody').empty();
            this.createTable();
        }

        this.exportToExcel = () => {
            let head = [];
            let data = [];
            this.el.find('thead tr th').each(function () {
                head.push($(this).html());
            });

            let i = 0;
            this.el.find('tbody tr').each(function () {
                let dataExcel = {};
                $(this).find('td').each(function () {
                    dataExcel[head[i]] = $(this).html();
                    i++;
                })
                data.push(dataExcel);
                i = 0;
            });

            console.log(data)
            try {

                json2excel({
                    data,
                    name: 'report',
                    formateDate: 'yyyy/mm/dd HH:MM:ss'
                });

            } catch (e) {
                console.error('export error');
            }
        };

        this.createTable();
    }
}


class TableStatic extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.table = widget.table;
        this.static = null;

        let self = this;

        this.createWidget();

        this.createTable = async () => {
            await getDataStatic()
            this.el = $('#' + this.widgetId);
            this.el.find('thead').append('<tr></tr>');
            for (let i = 0; i < this.table.col_labels.length; i++) {
                this.el.find('thead tr').append(`<th>${this.table.col_labels[i]}</th>`);
            };

            for (let k = 0; k < this.static.length; k++) {
                let rows = '';
                let date = null;
                for (let i = 0; i < this.table.rows.length; i++) {
                    rows += `<tr class="table-${k}">`;
                    for (let j = 0; j < this.table.col_labels.length; j++) {
                        if (j === 0) {
                            rows += `<td>${this.table.rows[i].label}</td>`;
                        } else {
                            let data = objectPath.get(this.static[k].data, this.table.rows[i].data[j - 1].val);
                            date = objectPath.get(this.static[k], 'date');
                            rows += `<td>${data}</td>`;
                        }
                    }
                    rows += '</tr>';
                }

                this.el.find('tbody').append(
                    `
                <tr class="text-left bg-light">
                    <td colspan="${this.table.col_labels.length}"><b>${date}</b> 
                    <i class="fas fa-angle-down table-dropdown" bind="table-${k}" style="float: right;"></i></td>
                </tr>
                ${rows}
                `);
            }



            $('#' + this.widgetId).parent().addClass('table-responsive');
            $('#' + this.widgetId).parent().css({
                "overflow-x": "auto",

            });
            // $('#' + this.widgetId).css({
            //     "width": "100%",
            // });

            $("#" + this.widgetId).on('click', '.table-dropdown', function () {
                let trToggle = $("#" + self.widgetId).find("." + $(this).attr('bind'));

                if ($(this).hasClass('fa-angle-down')) {
                    $(this).removeClass('fa-angle-down');
                    $(this).addClass('fa-angle-up')
                } else {
                    $(this).removeClass('fa-angle-up');
                    $(this).addClass('fa-angle-down')
                }

                trToggle.toggle();

            });

            //this.updateStatic();
        }

        let getDataStatic = async () => {
            await $.ajax({
                url: '/js/company/test-aggr.json',
                data: {},
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                success: (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    this.static = res;

                },
                error: (res) => {

                }
            })
        }


        this.updateStatic = async () => {
            await getDataStatic()
            try {
                let i = 0;

                let rows = this.table.rows;
                this.el.find('tbody tr').each(function () {
                    let j = 0;
                    $(this).find('td').not(':first').each(function () {
                        console.log(self.static);
                        let data = objectPath.get(self.static[i].data, rows[i].data[j].val);

                        $(this).html(data);
                        j++;
                    });
                    i++;
                });
                this.updateLastUpdate();
            } catch (error) {
                console.log(error);
            }
        }

        this.updatePropWidget = (tableEx) => {
            this.table = tableEx.getValue();
            this.datasources = tableEx.getValue().datasources;
            $('#' + this.widgetId).find('thead').empty();
            $('#' + this.widgetId).find('tbody').empty();
            this.createTable();
        }

        this.exportToExcel = () => {
            let head = [];
            let data = [];
            this.el.find('thead tr th').each(function () {
                head.push($(this).html());
            });

            let i = 0;
            this.el.find('tbody tr').each(function () {
                let dataExcel = {};
                $(this).find('td').each(function () {
                    dataExcel[head[i]] = $(this).html();
                    i++;
                })
                data.push(dataExcel);
                i = 0;
            });

            try {

                json2excel({
                    data,
                    name: 'report',
                    formateDate: 'yyyy/mm/dd HH:MM:ss'
                });

            } catch (e) {
                console.error('export error');
            }
        };

        this.createTable();
    }
}

class TextValue extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.textValue = widget.textValue;
        this.unit = widget.unit;
        this.rgb = widget.rgb;

        this.createWidget();

        this.createTextValue = () => {
            this.updateData();
        };

        this.updatePropWidget = () => {
            let el = $("#" + this.editModalId);
            let elValueDatasource = el.find(elements.DOMString.class.valueDatasource);
            let value_datasource = [{
                id: elValueDatasource.attr('service_id'),
                type: elValueDatasource.attr('label'),
                val: elValueDatasource.val(),
            }];
            this.datasources = value_datasource;
            this.sendUpdateSocket();
            this.updateData();
        }

        this.updateData = () => {
            //let data = Math.floor(Math.random() * (100 - 1));
            let data = Datasource.getValueRealtime(this.datasources[0])
            $("#" + this.widgetId).html(data);
            let timeLast =Datasource.getValueRealtime(this.datasources[0],'newDate');
            this.updateLastUpdate(timeLast);
        };

        this.createTextValue();
    }
}

class TextBox extends Widget {
    constructor(widget, gridData = null) {
        super(widget, gridData);
        this.textbox = widget.textbox;
        this.fontsize = widget.fontsize;

        this.createWidget();

        this.createTextBox = () => {
            // console.log($("#" + this.widgetId));
            $("#" + this.widgetId).html(this.textbox);
            $("#" + this.widgetId).css({
                "font-size": this.fontsize + "px"
            });
        };

        this.createTextBox();
    }
}

var widgetList = [];


class Datasources {
    constructor() {
        let listDatasource = null;

        let webservices = null;

        let datasources = {
            web_services: {
                realtime: {},
                firstData: {},
            },
            iot_services: {
                realtime: {},
                firstData: {},
            }
        };

        let ex = {
            web_services: {
                realtime: {},
                static: {},
                firstData: {},
            },
            iot_services: {
                realtime: {},
                static: {},
                firstData: {},
            }
        }


        let apiSelect = 'datasources';

        let keyInput = [];

        let dataAccess = [];

        let modalEdit = null;

        let apiCount = 0;

        let self = this;

        // let getWebServices = async () => {        
        //     await $.ajax({
        //         url: END_POINT + API.getWebServices,
        //         headers: {
        //             authorization: 'bearer ' + getCookie('token'),
        //         },
        //         success: (res, textStatus, xhr) => {
        //             checkAuthRes(xhr)
        //             listDatasource = res.data;
        //             webservices = res.data;
        //             listDatasource.map(data => {
        //                 $("#list_web_service").append(`
        //                 <div class="custom-control custom-checkbox mb-3">
        //                     <input type="checkbox" class="custom-control-input" id="id_${data.webservice_id}"  value="${data.webservice_id}" name="webservice_id">
        //                     <label class="custom-control-label" for="id_${data.webservice_id}" >${data.service_name}</label>
        //                 </div>`)
        //                 //$("#webservice_id").append(`<option value="${data.webservice_id}">${data.service_name}</option>`);
        //             });
        //         },
        //         error: (res) => {
        //             console.log(res);
        //         }
        //     });
        // };

        let getDatasource = async () => {
            await $.ajax({
                url: END_POINT + API.getDatasource,
                method: 'GET',
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                data: {
                    dashboard_id: $("#dashboard_id").html(),
                },
                success: (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    listDatasource = res.data;
                    console.log(listDatasource);
                    updateListDatasource();
                },
                error: (res) => {
                    console.log(res);
                }
            });
        };

        let addDatasource = () => {
            let webservice_id = [];
            let iot_service_id = [];

            $("input[name='webservice_id']").each(function () {
                webservice_id.push($(this).val());
            });

            $("input[name='iot_service_id']").each(function () {
                iot_service_id.push($(this).val());
            });

            $.ajax({
                url: END_POINT + API.addDatasource,
                method: 'POST',
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                data: {
                    dashboard_id: $("#dashboard_id").html(),
                    name: $("#name_datasource").val(),
                    webservice_id: webservice_id,
                    timeInterval: 4500,
                },
                success: (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    getDatasource();
                    $("#addDatasource").modal('hide');
                },
                error: (res) => {
                    console.log(res);
                }
            });
        };

        let updateListDatasource = () => {
            $("#list_datasource").empty();
            $(".select-datasource").empty();
            let html = "" //"<h5>Datasource</h5>";
            let opt = "<option value=''>--Select datasource--</option>";
            opt += `<optgroup label="Web services">`
            listDatasource.webservices.map((data, index) => {
                // html += `<div class="row">
                //             <div class="col-2 edit-datasource" title="Edit" index=${index} style="cursor:pointer"> 
                //                 ${data.name}
                //             </div>
                //             <div class="col-2 unActiveApi" id="datasource-isActive-${index}">
                //                 <b>Not active</b>
                //             </div>
                //             <div class="col-3" id="datasource-${index}">

                //             </div>
                //             <div class="col-1">
                //                 <i class="fas fa-trash-alt remove-datasource" id="${data.id}"></i>
                //             </div>
                //         </div>`;
                opt += `<option value='${data.webservice_id}'>${data.service_name}</option>`;
                //apiCount++;
                //await getApiDatasource(index);
            });

            opt += `</optgroup>`
            opt += `<optgroup label="IoT services">`
            listDatasource.iot.map(async (data, index) => {
                opt += `<option value='${data.iotservice_id}'>${data.iot_name}</option>`;
                //apiCount++;
                //await getApiDatasource(index);
            });
            opt += `</optgroup>`


            // $(".edit-datasource").unbind().click(function () {

            // });


            socket_dashboards.on('broadcast', function (data) {
                //console.log(data)
                if (data.type === "web_services") {
                    datasources.web_services.realtime[data.service_id] = data.data;
                } else if (data.type === "iot_services") {
                    datasources.iot_services.realtime[data.service_id] = data.data;
                }
                //console.log(datasources)


                widgetList.map(widget => {
                    if (widget.updateSocket) {
                        widget.updateSocket(data.service_id, data.type);
                    } else if (widget.updateData) {
                        if (widget.datasources[0].id === data.service_id && widget.datasources[0].type === data.type) {
                            widget.updateData();
                        }
                    }
                })
            });

            // setInterval(() => {
            //     checkTimeToUpdate();
            // }, 1000);


            $(".select-datasource").html(opt);

            // let list_datasource = $("#list_datasource").html(html);

            // list_datasource.find('.remove-datasource').unbind().click(function () {
            //     let id = $(this).attr('id');
            //     let datasource = findDatasource(id);
            //     let check = false;
            //     widgetList.map(widget => {
            //         widget.datasource.map(_datasource => {
            //             if (_datasource.split('.')[0] === datasource.name) {
            //                 check = true;
            //             }
            //         })

            //     })
            //     if (!check) {
            //         swal({
            //             title: "Are you sure?",
            //             text: `to delete datasource name : ${datasource.name}`,
            //             icon: "warning",
            //             buttons: true,
            //             dangerMode: true,
            //         }).then((willDelete) => {
            //             if (willDelete) {
            //                 deleteDatasource(id, datasource.name);

            //             } else {
            //                 return;
            //             }
            //         });
            //     } else {
            //         swal({
            //             title: "Warning !",
            //             text: `Can't delete datasource name : ${datasource.name} because have widget used this datasource`,
            //             icon: "warning",
            //             dangerMode: true,
            //         });
            //     }
            // });
        };

        let deleteDatasource = (id, name) => {
            $.ajax({
                url: END_POINT + API.deleteDatasource,
                method: 'DELETE',
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                data: {
                    dashboard_id: $("#dashboard_id").html(),
                    id: id,
                },
                success: (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    // let index = datasources.findIndex(datasource => datasource.name == name);
                    // datasources.splice(index, 1);
                    $(`.remove-datasource[id='${id}']`).parent().parent().remove();
                },
                error: (res) => {
                    console.log(res);
                }
            });
        };

        // let onEditDatasourceClick = () => {
        //     if (modalEdit === null) {
        //         modalEdit = `    <div class="modal fade" id="addDatasource">
        //                             <div class="modal-dialog modal-lg">
        //                                 <div class="modal-content">

        //                                     <div class="modal-header">
        //                                         <h4 class="modal-title">Edit Datasource</h4>
        //                                         <button type="button" class="close" data-dismiss="modal">&times;</button>
        //                                     </div>

        //                                     <div class="modal-body">
        //                                         <div class="row">
        //                                             <div class="col-12">
        //                                                 <label for="">Name</label>
        //                                                 <input type="text" id="edit-name-datasource" class="form-control">
        //                                             </div>
        //                                         </div>
        //                                         <div class="row">
        //                                             <div class="col-6">
        //                                                 <label for="">Channel</label>
        //                                                 <select name="" id="edit-webservice_id" class="form-control">
        //                                                     <option value="">--Select Channel--</option>
        //                                                 </select>
        //                                             </div>
        //                                             <div class="col-6">
        //                                                 <label for="">Set time interval (s)</label>
        //                                                 <input type="number" id="add-data-time-interval" class="form-control">
        //                                             </div>
        //                                         </div>
        //                                     </div>

        //                                     <div class="modal-footer">
        //                                         <a class="btn btn-success btn-block" id="btn-add-new-datasource" href="#">Save</a>
        //                                     </div>
        //                                 </div>
        //                             </div>
        //                         </div>`;
        //     }
        // };

        // let checkTimeToUpdate = () => {
        //     listDatasource.map(async (data, index) => {
        //         let diff = Dashboard.diffTime(data.lastUpdate, data.timeInterval);
        //         if (diff >= data.timeInterval) {
        //             await getApiDatasource(index);
        //         }
        //         return;
        //     });

        // };

        let getApiDatasource = async (index) => {
            //url: '/js/company/test-api2.json',
            let url = listDatasource[index].URL;
            let name = listDatasource[index].name;
            await $.ajax({
                url: '/js/company/test-api2.json',
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                success: async (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    // let lastUpdate = new Date();
                    // listDatasource[index].lastUpdate = lastUpdate;
                    // $("#datasource-" + index).html(lastUpdate.toDateString() + " " + lastUpdate.toLocaleTimeString());
                    // $("#datasource-isActive-" + index).html('<b>Active</b>');
                    // $("#datasource-isActive-" + index).removeClass('unActiveApi');
                    // $("#datasource-isActive-" + index).addClass('activeApi');
                    datasources['web_service']['realtime'][name] = res;
                    // if (apiCount === listDatasource.length) {
                    //     state.loadingApi = true;
                    // }
                },
                error: (res) => {
                    console.log(res);
                }
            });

            await $.ajax({
                url: '/js/company/test-api-static.json',
                headers: {
                    authorization: 'bearer ' + getCookie('token'),
                },
                success: async (res, textStatus, xhr) => {
                    checkAuthRes(xhr)
                    let lastUpdate = new Date();
                    listDatasource[index].lastUpdate = lastUpdate;
                    $("#datasource-" + index).html(lastUpdate.toDateString() + " " + lastUpdate.toLocaleTimeString());
                    $("#datasource-isActive-" + index).html('<b>Active</b>');
                    $("#datasource-isActive-" + index).removeClass('unActiveApi');
                    $("#datasource-isActive-" + index).addClass('activeApi');
                    datasources['web_service']['firstData'][name] = res;
                    if (apiCount === listDatasource.length) {
                        state.loadingApi = true;
                    }
                },
                error: (res) => {
                    console.log(res);
                }
            });
        };

        let findDatasource = (id, label) => {
            if (label === "web_services") {
                return listDatasource.webservices.find(data => {
                    return data.webservice_id == id;
                });
            } else if (label === "iot_services") {
                return listDatasource.iot.find(data => {
                    return data.iotservice_id == id;
                });
            }
        };

        let getKeyDatasource = (index, data) => {
            if (typeof (data) == 'object') {
                if (index == keyInput.length) {
                    return [Object.keys(data), data] ? [Object.keys(data), data] : [];
                }
                return getKeyDatasource(index + 1, data[keyInput[index]]);
            }
        };

        let getKeyObject = (data) => {
            if (typeof (data) == 'object') {
                return Object.keys(data);
            }
        };

        let forList = async (dataList, exData) => {
            let keys = Object.keys(exData);
            let html = "";
            await keys.map((_key) => {
                html += `<li class="value-data list-group-item" style="cursor:pointer" value="${_key}">${_key} : ${exData[_key]}</li>`;
            });



            await dataList.html(html);

            return true;
        }

        let createDataList2 = async (el, datasource, label, isRealtime = true) => {

            el.attr('label', label);
            let dataList = el.parent().find(".data-list");
            let loader = el.parent().find(".loader");

            loader.show();

            // dataList.mCustomScrollbar('destroy');

            dataList.empty();

            let exData = null;


            if (label === "web_services") {
                el.attr("service_id", datasource.webservice_id)
                exData = await getFlatObjectV2(state.isRealTime === true ? ex.web_services.realtime[datasource.webservice_id] : ex.web_services.static[datasource.webservice_id]);
            } else if (label === "iot_services") {
                el.attr("service_id", datasource.iotservice_id)
                exData = await getFlatObjectV2(state.isRealTime === true ? ex.iot_services.realtime[datasource.iotservice_id] : ex.iot_services.static[datasource.iotservice_id]);
            }

            await forList(dataList, exData)



            loader.hide();

            // dataList.mCustomScrollbar({
            //     theme: "minimal-dark"
            // });

            dataList.parent().find(".data-list").hover(function () {
                $(this).closest('.value-datasource').focus();
            }, function () {
                $(this).prev().blur();
                $(this).hide();
            });

            dataList.find('.value-data').unbind().click(function () {
                let el_val = $(this).parent().parent().find('.value-datasource,.value-group-data');
                let a = $(this).attr("value");
                el_val.val(a);
                el_val.focus();
            });
        }

        let createDataList = (api, el = null) => {
            $(el).parent().find(".data-list").empty();
            //let js = apiSelect + "['" + api + "']";
            let js = api;
            $(el).val(js);
            updateDataList(js, el);
        };

        let updateDataList = (value, el = null) => {

            try {
                keyInput = value.match(REG);
                //let key = getKeyDatasource(2, datasources[keyInput[1]]);
                let key = getKeyObject(objectPath.get(datasources.realtime, value));
                el.parent().find(".data-list").empty();

                let html = "";
                if (keyInput.length > 1)
                    html += `<li class="back-value-data list-group-item" back="${keyInput.slice(0, keyInput.length - 1).join('.')}" style="cursor:pointer">Back</li>`;

                key.map(_key => {
                    let data = objectPath.get(datasources.realtime, `${value}.${_key}`);
                    html += `<li class="value-data list-group-item" style="cursor:pointer" value="${_key}">${_key} : ${data}</li>`;
                });
                let data_list = el.parent().find(".data-list").append(html);

                data_list.parent().find('.data-list').hover(function () {
                    $(this).closest('.value-datasource').focus();
                }, function () {
                    $(this).prev().blur();
                    $(this).hide();
                });

                data_list.find('.value-data').unbind().click(function () {
                    let el_val = $(this).parent().parent().find('.value-datasource,.value-group-data');
                    let a = $(el_val).val();
                    a += `.${$(this).attr('value')}`;
                    $(el_val).val(a);
                    updateDataList($(el_val).val(), el_val);
                    $(el_val).focus();

                    $(".value-group-data").change();
                });

                data_list.find('.back-value-data').unbind().click(function () {
                    let back = $(this).attr('back');
                    // let value = "datasource";
                    // for (let i = 1; i < back.length; i++) {
                    //     value += `['${back[i]}']`;
                    // }
                    $(this).parent().parent().find('.value-datasource,.value-group-data').val(back);
                    updateDataList(back, $(this).parent().parent().find('.value-datasource,.value-group-data'));
                });
                $(".data-list").scrollTop(0);


            } catch (error) {

            }

            // $("#Mutiline_value  .data-list,#Radar  .data-list,#Table  .data-list").hover(function () {
            //     $(this).closest('.value-datasource').focus();
            // }, function () {
            //     $(this).prev().blur();
            //     $(this).hide();
            // });

            // $(".value-data").unbind().click(function () {
            //     let el_val = $(this).parent().parent().find('.value-datasource,.value-group-data');
            //     let a = $(el_val).val();
            //     a += `['${$(this).attr('value')}']`;
            //     $(el_val).val(a);
            //     updateDataList($(el_val).val(), el_val);
            //     $(el_val).focus();

            //     $(".value-group-data").change();
            // });

            // $(".back-value-data").unbind().click(function () {
            //     let back = $(this).attr('back').split(',');
            //     let value = "datasource";
            //     for (let i = 1; i < back.length; i++) {
            //         value += `['${back[i]}']`;
            //     }
            //     $(this).parent().parent().find('.value-datasource,.value-group-data').val(value);
            //     updateDataList(value, $(this).parent().parent().find('.value-datasource,.value-group-data'));
            // });
        };


        let groupData = {
            createGroupData: (api, el = null) => {
                el.find(".data-list").empty();
                el.find('.value-group-data').val(api);
                groupData.updateDataGroup(api, el);
            },

            updateDataGroup: (api, el) => {
                try {
                    let key = getKeyObject(objectPath.get(datasources.realtime, api));
                    el.find(".data-list").empty();
                    let html = "";
                    key.map(_key => {
                        html += `<li class="value-data list-group-item" style="cursor:pointer" value="${_key}">${_key}</li>`;
                    });


                    let data_list = el.find(".data-list-group").append(html);

                    data_list.find('.value-data').unbind().click(function () {
                        let el_val = el.parent().parent().find('.value-group-data');
                        let a = $(el_val).val();
                        a += `.${$(this).attr('value')}`;
                        $(el_val).val(a);
                        groupData.updateDataGroup($(el_val).val(), el);
                        $(el_val).focus();

                        $(".value-group-data").change();
                    });

                    data_list.parent().find(".data-list").hover(function () {
                        $(this).closest('.value-datasource').focus();
                    }, function () {
                        $(this).prev().blur();
                        $(this).hide();
                    });

                    $(".data-list").scrollTop(0);
                    // if (keyInput.length > 2)
                    //     el.parent().find(".data-list").prepend(`<li class="back-value-data list-group-item" back="${keyInput.slice(0, keyInput.length - 1).join(',')}" style="cursor:pointer">Back</li>`);

                } catch (error) {
                    console.log(error);
                }

                $("#Mutiline_group_data .group-data .back-value-data,#map_group_data .group-data .back-value-data").unbind().click(function () {
                    let back = $(this).attr('back').split(',');
                    let value = "datasource.realtime";
                    for (let i = 1; i < back.length; i++) {
                        value += `['${back[i]}']`;
                    }
                    $(this).parent().parent().find('.value-datasource,.value-group-data').val(value);
                    updateDataList(value, $(this).parent().parent().find('.value-datasource,.value-group-data'));
                });
            },


            createDataValue: (api, el) => {
                try {
                    let key = getKeyObject(objectPath.get(datasources.realtime, api));
                    el.find(".data-list-value").empty();
                    let html = "";
                    key.map(_key => {
                        let data = objectPath.get(datasources.realtime, `${$(".value-group-data").val()}.0.${_key}`);
                        html += `<li class="value-data list-group-item" style="cursor:pointer" value="${_key}">${_key} : ${data}</li>`;
                    });

                    let data_list = el.find(".data-list-value").append(html);

                    data_list.find('.value-data').unbind().click(function () {
                        let el_val = $(this).parent().parent().find('.value-datasource');
                        let a = $(el_val).val();
                        a += `.${$(this).attr('value')}`;
                        $(el_val).val(a);
                        $(el_val).focus();
                        groupData.updateDataValue(a, el_val)
                    });;

                    data_list.parent().find(".data-list").hover(function () {
                        $(this).closest('.value-datasource').focus();
                    }, function () {
                        $(this).prev().blur();
                        $(this).hide();
                    });

                    $(".data-list-value").scrollTop(0);
                    // if (keyInput.length > 2)
                    //     el.parent().find(".data-list").prepend(`<li class="back-value-data list-group-item" back="${keyInput.slice(0, keyInput.length - 1).join(',')}" style="cursor:pointer">Back</li>`);

                } catch (error) {
                    console.log(error);
                }


                // $(".back-value-data").unbind().click(function () {
                //     let back = $(this).attr('back').split(',');
                //     let value = "datasource";
                //     for (let i = 1; i < back.length; i++) {
                //         value += `['${back[i]}']`;
                //     }
                //     $(this).parent().parent().find('.value-datasource,.value-group-data').val(value);
                //     updateDataList(value, $(this).parent().parent().find('.value-datasource,.value-group-data'));
                // });
            },

            updateDataValue: (api, el) => {
                try {

                    let key = getKeyObject(objectPath.get(datasources.realtime, $(".value-group-data").val() + '.0' + el.val()));
                    console.log($(".value-group-data").val() + '.0' + el.val());

                    let keyInput = [];
                    if (api != "") {
                        keyInput = api.match(REG);
                    }

                    el.parent().find(".data-list-value").empty();
                    let html = "";

                    if (keyInput.length == 1)
                        html += `<li class="back-value-data list-group-item" back="" style="cursor:pointer">Back</li>`;
                    else {
                        html += `<li class="back-value-data list-group-item" back="${keyInput.slice(0, keyInput.length - 1).join('.')}" style="cursor:pointer">Back</li>`;
                    }

                    key.map(_key => {
                        let data = objectPath.get(datasources.realtime, `${$(".value-group-data").val()}.0${el.val()}.${_key}`);
                        //console.log(`${datasources}${$(".value-group-data").val()}.0${api}.${_key}`, api, data);
                        html += `<li class="value-data list-group-item" style="cursor:pointer" value="${_key}">${_key} : ${data} </li>`;
                    });

                    $(".data-list-value").scrollTop(0);

                    let data_list = el.parent().find(".data-list-value").append(html);

                    data_list.find(".value-data").unbind().click(function () {
                        let el_val = $(this).parent().parent().find('.value-datasource');
                        let a = $(el_val).val();
                        a += `.${$(this).attr('value')}`;
                        $(el_val).val(a);
                        $(el_val).focus();
                        groupData.updateDataValue(a, el_val)
                    });

                    data_list.find(".back-value-data").unbind().click(function () {
                        let value_datasource = $(this).parent().parent().find('.value-datasource')
                        let back = $(this).attr('back');
                        if (back == '') {
                            value_datasource.val('');
                        } else {
                            value_datasource.val('.' + back);

                        };
                        groupData.updateDataValue(back, value_datasource)

                    });

                    data_list.parent().find(".data-list").hover(function () {
                        $(this).closest('.value-datasource').focus();
                    }, function () {
                        $(this).prev().blur();
                        $(this).hide();
                    });


                } catch (error) {
                    console.log(error);
                }
            }
        }

        // this.setDataAccess = (data) => {
        //     dataAccess = data;
        // };

        // this.getDatasourceValue = (index, data) => {
        //     if (typeof (data[dataAccess[index]]) == 'object') {
        //         return this.getDatasourceValue(index + 1, data[dataAccess[index]]);
        //     }
        //     return data[dataAccess[index]];
        // };

        // this.fatoryGetDatasourceValue = (inputDataAccess, key) => {
        //     try {
        //         dataAccess = inputDataAccess;
        //         return this.getDatasourceValue(2, datasources[key]);
        //     } catch (error) {

        //     }
        // };

        this.getDatasources = () => {
            return datasources;
        };

        let getLabelSelectGroup = (el) => {
            let selected = $(':selected', el);
            return selected.closest('optgroup').attr('label').toLowerCase().replace(' ', '_');
        }

        let getRawData = async (datasource, label) => {
            //url: '/js/company/test-api2.json',
            let data = null;
            if (label === "web_services") {
                data = await axios.get('/js/company/test-api2.json');
                ex.web_services.realtime[datasource.webservice_id] = data.data;
            } else if (label === "iot_services") {
                data = await axios.post('http://203.151.136.15/node/iotService/getInputIoTData', {
                    tableDW_name: datasource.iot_name_DW
                });

                ex.iot_services.realtime[datasource.iotservice_id] = data.data[0];

            }
        }

        let getStaticData = async (datasource, label) => {
            //url: '/js/company/test-api2.json',
            let data = await axios.get('/js/company/test-aggr.json');
            if (label === "web_services") {
                ex.web_services.static[datasource.webservice_id] = data.data[0].data;
            } else if (label === "iot_services") {
                ex.iot_services.static[datasource.iotservice_id] = data.data[0].data;
            }
        }


        this.addEventTable = async (el, isAddCol) => {
            el.find(".data-list").hide();
            let el_value = el.parent().parent().next().find('table');

            if (el.val() != "") {
                let label = getLabelSelectGroup(el);
                let datasource = findDatasource(el.val(), label);

                state.isRealTime = true;
                await getStaticData(datasource, label);

                let elSend = null;
                if (isAddCol) {
                    elSend = el_value.find("tbody tr").find('td:last .value-datasource');
                } else {
                    elSend = el_value.find("tbody tr:last > td .value-datasource")
                }

                createDataList2(elSend, datasource, label, state.isRealTime);

                elSend.on('focus', function () {
                    console.log('te');
                    el.find('.data-list.active-data').hide().removeClass('active-data');
                    $(this).parent().find('.list-group').addClass('active-data');
                    $(this).parent().find('.list-group').show();
                });

                elSend.on('keyup', function () {
                    let value = $(this).val().toLowerCase();
                    let datalist = $(this).next().next();
                    datalist.find(".value-data").filter(function () {
                        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
                    });
                });


            } else {
                el.find(".data-list").empty();
            }
        }


        this.addEventMap = async (el = elements.mapValue, refresh = false) => {
            let formhtml = $("#map_value_layout").first().html();
            let html = el.append(formhtml);
            let apiId = el.find(elements.DOMString.class.selectDatasource).val();
            if (apiId != '') {

                let label = getLabelSelectGroup(el.find(elements.DOMString.class.selectDatasource));
                let datasource = findDatasource(apiId, label);
                await getRawData(datasource, label);
                state.apiName = datasource.name;
                html.find('.value-of-map:last ' + elements.DOMString.class.valueDatasource).next().hide();
                createDataList2(html.find('.value-of-map:last ' + elements.DOMString.class.valueDatasource), datasource, label);
            } else {
                $(".value-of-map").find(elements.DOMString.class.dataList).empty();
            }

            if (refresh) {
                html.find('.value-of-map:last ' + elements.DOMString.class.valueDatasource).on('focus', function () {
                    state.editModalIdSelect.find('.data-list.active-data').hide().removeClass('active-data');
                    $(this).next().addClass('active-data');
                    $(this).next().show();
                });

                html.find('.value-of-map:last ' + elements.DOMString.class.valueDatasource).keyup(function () {
                    let value = $(this).val().toLowerCase();
                    let datalist = $(this).next();
                    datalist.find(".value-data").filter(function () {
                        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
                    });
                });
            }

        }



        this.setEventEl = async (el, widget, isAdd = false) => {
            el.unbind().change(async function () {
                if (widget.type !== WIDGET_TYPE.TABLE) {
                    let value = null;
                    if (widget.type !== WIDGET_TYPE.RADAR) {
                        if (widget.type === WIDGET_TYPE.MAP) {
                            value = el.parent().parent().parent();
                        } else {
                            value = el.parent().parent();
                        }
                    } else {
                        value = el.parent().parent().next().next();
                    }


                    value.find(".value-datasource").val('');
                    value.find(".data-list").hide();

                    if ($(this).val() != '') {
                        let label = getLabelSelectGroup(this);
                        let datasource = findDatasource($(this).val(), label);
                        if (widget.type.search("static") < 0) {
                            state.isRealTime = true;
                            await getRawData(datasource, label);
                        } else {
                            state.isRealTime = false;
                            await getStaticData(datasource, label);
                        }
                        state.apiName = datasource.name;
                        //$(this).parent().parent().next().find(".value-datasource").focus();
                        createDataList2(value.find(".value-datasource"), datasource, label, state.isRealTime);
                        //createDataList(datasource.name, value.find(".value-datasource"));
                    } else {
                        value.find(".data-list").empty();
                    }
                } else {

                }
            });

            if (!isAdd) {
                let value = null;
                if (widget.type !== WIDGET_TYPE.RADAR) {
                    if (widget.type === WIDGET_TYPE.MAP) {
                        value = el.parent().parent().parent();
                    } else {
                        value = el.parent().parent();
                    }
                } else {
                    value = el.parent().parent().next().next();
                }


                value.find(".data-list").hide();

                if (el.val() != "") {
                    let label = getLabelSelectGroup(el);
                    let datasource = findDatasource(el.val(), label);
                    if (widget.type.search("static") < 0) {
                        state.isRealTime = true;
                        await getRawData(datasource, label);
                    } else {
                        state.isRealTime = false;
                        await getStaticData(datasource, label);
                    }
                    if (widget.type != WIDGET_TYPE.TABLE) {
                        createDataList2(value.find(".value-datasource"), datasource, label, state.isRealTime);
                    } else {
                        createDataList2(state.editModalIdSelect.find(".value-datasource"), datasource, label, state.isRealTime);
                    }

                } else {
                    value.find(".data-list").empty();
                }
            }


            $(`#${widget.editModalId} .modal-body `).unbind().find('.value-datasource').on('focus', function () {
                $(`#${widget.editModalId} .modal-body`).find('.data-list.active-data').hide().removeClass('active-data');
                $(this).parent().find('.list-group').addClass('active-data');
                $(this).parent().find('.list-group').show();
            });

            $(`#${widget.editModalId} .modal-body .value-datasource`).keyup(function () {
                let value = $(this).val().toLowerCase();
                let datalist = $(this).parent().find('.data-list').first();
                datalist.find(".value-data").filter(function () {
                    $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
                });
            });

            $(`#${widget.editModalId} .modal-body`).unbind().on('click', '.remove-value', function () {
                $(this).parent().parent().remove();
            });



            $(`#${widget.editModalId} .modal-body .remove-radar-labels`).unbind().on('click', function () {
                let radarBind = $(this).attr('bind');
                $("." + radarBind).parent().parent().remove();
                $(this).parent().parent().remove();
            });

            // $(`#${widget.editModalId} .modal-body`).unbind().on('click', '.remove-datasource-radar', function () {
            //     $(this).parent().remove();
            //     if (radarEx)
            //         radarEx.updateRadarExample();
            // });



        }


        this.setEventElRadar = async (el, isSetLast = false) => {

            let el_value = el.parent().parent().next().next();

            if (!isSetLast) {
                el_value.find(".value-datasource").val('');
                el_value.find(".data-list").hide();
                el_value.find(".data-list").empty();
            }

            if (el.val() != '') {

                let label = getLabelSelectGroup(el);
                let datasource = findDatasource(el.val(), label);
                await getRawData(datasource, label);
                state.apiName = datasource.name;
                if (!isSetLast) {
                    createDataList2(el_value.find(".value-datasource"), datasource, label);
                } else {
                    createDataList2(el_value.find(".value-datasource:last"), datasource, label);
                }
                //createDataList(datasource.name, $(el_value).find(".value-datasource"));
            }

        }



        let bindElement = async () => {
            $("#btn_add_param").unbind().click(function () {
                let html = $("#layout_param_add").html();

                let form_add_param = $("#form_add_param").append(html);
                form_add_param.find(".remove-param").unbind().click(function () {
                    $(this).parent().parent().remove();
                });
            });

            $("#btn-add-datasource").unbind().click(function () {
                $("#addDatasource").modal('show');
            });

            $("#btn-add-new-datasource").unbind().click(function () {
                addDatasource();
            });

            $('#Gauges,#TextValue,#text-line').on('change', '.select-datasource', async function () {
                $(this).parent().next().find(".value-datasource").val('');
                $(this).parent().next().find(".data-list").hide();
                let value = $(this).parent().parent();

                if ($(this).val() != '') {
                    let label = getLabelSelectGroup(this);
                    let datasource = findDatasource($(this).val(), label);
                    await getRawData(datasource, label);
                    state.apiName = datasource.name;
                    $(this).parent().next().find(".value-datasource").focus();
                    createDataList2(value.find(".value-datasource"), datasource, label);
                    //createDataList(datasource.name, $(this).parent().next().find(".value-datasource"));
                } else {
                    $(this).parent().next().find(".data-list").empty();
                }
            });

            $("#Mutiline_value").on('change', '.select-datasource', async function () {
                let value = $(this).parent().parent();
                value.find(".value-datasource").val('');
                value.find(".data-list").hide();

                if ($(this).val() != '') {
                    let label = getLabelSelectGroup(this);
                    let datasource = findDatasource($(this).val(), label);
                    if (state.isRealTime) {
                        await getRawData(datasource, label);
                    } else {
                        await getStaticData(datasource, label);
                    }
                    state.apiName = datasource.name;
                    $(this).parent().parent().next().find(".value-datasource").focus();
                    createDataList2(value.find(".value-datasource"), datasource, label, state.isRealTime);
                    //createDataList(datasource.name, value.find(".value-datasource"));
                } else {
                    value.find(".data-list").empty();
                }
            });


            $("#map_value").on('change', '.select-datasource', async function () {
                $("#map_value").find(".value-datasource").val('');
                $("#map_value").find(".data-list").hide();

                if ($(this).val() != '') {
                    let label = getLabelSelectGroup(this);
                    let datasource = findDatasource($(this).val(), label);
                    await getRawData(datasource, label);
                    state.apiName = datasource.name;
                    //$(this).parent().parent().next().find(".value-datasource").focus();
                    createDataList2($("#map_value").find(".value-datasource"), datasource, label);
                    //createDataList(datasource.name, $("#map_value").find(".value-datasource"));
                } else {
                    $("#map_value").find(".list-group").empty();
                }
            });

            $("#Mutiline_group_data,#map_group_data").on('change', '.select-datasource', function () {
                $("#Mutiline_group_data,#map_group_data").find(".value-datasource").val('');
                $("#Mutiline_group_data,#map_group_data").find(".data-list").hide();
                if ($(this).val() != '') {
                    let datasource = findDatasource($(this).val());
                    state.apiName = datasource.name;
                    groupData.createGroupData(datasource.name, $("#Mutiline_group_data,#map_group_data"));
                } else {
                    $(".data-list").empty();
                    $(".value-group-data").val('');
                }
            });


            $("#Mutiline_group_data,#map_group_data").on('change', '.value-group-data', function () {
                let el = $("#Mutiline_group_data,#map_group_data");
                let data = objectPath.get(datasources.realtime, $(this).val());
                if (validate.isArray(data)) {
                    el.find("input[name='end']").val(data.length - 1);
                    groupData.createDataValue($(this).val() + ".0", el);
                } else {
                    $(".data-list-value,data-list-label").empty();
                }

            });

            $("#Mutiline_group_data").on('change', '.data-list-value', function () {

            });

            $("#Table").on('change', '.select-datasource', async function () {
                $("#Table").find(".value-datasource").val('');
                $("#Table").find(".data-list").hide();
                $("#Table").find(".data-list").empty();

                let value = $(this).parent().parent();


                if ($(this).val() != '') {
                    // let datasource = findDatasource($(this).val());
                    // state.apiName = datasource.name;
                    // createDataList(datasource.name, $("#Table").find(".value-datasource"));
                    let label = getLabelSelectGroup(this);
                    let datasource = findDatasource($(this).val(), label);
                    if (state.isRealTime) {
                        await getRawData(datasource, label);
                    } else {
                        await getStaticData(datasource, label);
                    }
                    state.apiName = datasource.name;
                    createDataList2($("#Table").find(".value-datasource"), datasource, label);
                }
            });

            $('#Radar_value').on('change', '.select-datasource', function () {
                self.setEventElRadar($(this));
            });

            $("#addWidget .modal-body").on('focus', '.value-datasource,.value-group-data', function () {
                $("#addWidget").find('.data-list.active-data').hide().removeClass('active-data');
                $(this).parent().find('.list-group').addClass('active-data');
                $(this).parent().find('.list-group').show();
            });

            $('#Mutiline_value,#Gauges,#TextValue,#text-line,#Radar,#Table,#map_value').on('keyup', '.value-datasource', function () {
                //updateDataList($(this).val(), $(this));
                let value = $(this).val().toLowerCase();
                let datalist = $(this).parent().find('.data-list');
                datalist.find(".value-data").filter(function () {
                    $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
                });
            });

            $("#btn-add-value-Mutiline").unbind().click(function () {
                let formhtml = $("#line_value_layout").first().html();
                let html = elements.mutiLineValue.append(formhtml);
                //let apiId = elements.mutiLineValue.find(elements.DOMString.class.selectDatasource).val();
                // if (apiId != '') {
                //     let datasource = findDatasource(apiId);
                //     html.find(elements.DOMString.class.dataList).hide();
                //     html.find(elements.DOMString.class.dataList).removeClass('active-data');
                //     createDataList(datasource.name, html.find(elements.DOMString.class.valueDatasource).last());
                // } else {
                //     $(this).parent().parent().next().find(elements.DOMString.class.dataList).empty();
                // }

            });

            $(".btn-add-point-map").click(function () {
                self.addEventMap();

            });
        };

        this.getValueRealtime = (datasource, val = null) => {
            if (datasource.type === "web_services") {
                return objectPath.get(datasources.web_services.realtime[datasource.id], val ? val : datasource.val);
            } else if (datasource.type === "iot_services") {
                return objectPath.get(datasources.iot_services.realtime[datasource.id], val ? val : datasource.val);
            }
        }

        this.getDatasourceRealtime = (service_id, type) => {
            if (type === "web_services") {
                return datasources.web_services.realtime[service_id];
            } else if (type === "iot_services") {
                return datasources.iot_services.realtime[service_id];
            }
        }

        this.getValueFirstData = async (datasource) => {
            if (datasource.type == "web_services") {
                if (!datasources.web_services.firstData[datasource.id]) {
                    await this.getFirstApi(datasource.id, datasource.type)
                }
                return datasources.web_services.firstData[datasource.id];
            } else if (datasource.type == "iot_services") {
                return datasources.iot_services.firstData[datasource.id];
            }
        }

        this.getValueRealtimeGroup = (datasource_path, i) => {
            return objectPath.get(datasources.realtime, datasource_path.replace('[]', i));
        }

        let hasService = (service_id, type) => {
            if (type === "web_services") {
                if (datasources.web_services.firstData[service_id]) {
                    return true;
                }
            } else if (type === "iot_services") {
                if (datasources.iot_services.firstData[service_id]) {
                    return true;
                }
            }

            return false;
        }

        let findListDatasource = (service_id, type) => {
            let list = null;
            if (type === "web_services") {
                list = listDatasource.webservices.filter(_data => {
                    return _data.webservice_id == service_id;
                })
            } else if (type === "iot_services") {
                list = listDatasource.iot.filter(_data => {
                    return _data.iotservice_id == service_id;
                })
            }
            return list;
        }


        this.getFirstApi = async (service_id, type) => {
            let realtime = null;
            let firstData = null
            let list = findListDatasource(service_id,type)[0];
            let end_date = new Date();
            let start_date =  new Date(moment(end_date).subtract(24, 'hours').format('YYYY-MM-DD HH:mm:ss'));;
            if (type === "web_services") {
                if (!hasService(service_id, type)) {
                    realtime = await axios.get('/js/company/test-api2.json');
                    datasources.web_services.realtime[service_id] = realtime.data
                }
                firstData = await axios.get('/js/company/test-api-static.json');
                datasources.web_services.firstData[service_id] = firstData.data
            } else if (type === "iot_services") {
                if (!hasService(service_id, type)) {
                    realtime = await axios.post(`${API_DW}iotService/getInputIoTData`, {
                        tableDW_name: list.iot_name_DW
                    });
                    datasources.iot_services.realtime[service_id] = realtime.data[0]
                }
                firstData = await axios.post(`${API_DW}iotService/getInputIoTData_Time`,{
                    tableDW_name: list.iot_name_DW,
                    start_date : start_date,
                    end_date : end_date
                });
                datasources.iot_services.firstData[service_id] = firstData.data
            }
            return true;
        };



        this.initCreate = async () => {
            await bindElement();
            //await getWebServices();
            await getDatasource();
        };
    }
}

class Dashboard {
    constructor() {

        let options = {
            cellHeight: 80,
            verticalMargin: 10,
            float: false
        };

        let grid = null;

        let time = null;



        let getDateTimeNow = () => {
            let d = new Date();
            //return d.getDate() + "-" + d.getMonth() + "-" + d.getFullYear() + " " + d.getHours() + ":" + d.getMinutes() + ":" + d.getSeconds();
            return d.toUTCString();
        };

        let checkHasService = async (datasources) => {
            let check = null;
            for (let i = 0; i < datasources.length; i++) {
                check = await Datasource.getFirstApi(datasources[i].id, datasources[i].type);
            }
            return check;
        }

        let bindElement = () => {

        };

        let updateDatalast = async () => {
            time = setInterval(() => {
                // && state.loadingApi
                if (widgetList.length > 0 /*&& state.loadingApi*/ ) {
                    updateData([...widgetList]);
                }
                else{
                    $("#loading").remove();
                }
            }, 1000);
        };

        let updateData = (widgets) => {
            for (var i = 0; i < widgets.length; i++) {
                let widget = widgets[i];

                if (widget.updateData) {
                    if (true /*Dashboard.diffTime(widget.lastUpdate, widget.timeInterval) >= widget.timeInterval || state.firstTime*/ ) {

                        if (!widget.firstLoadData) {
                            widget.updateData();
                        } else {
                            widget.updateFirstData();
                        }

                    } else if (widget.liveData) {
                        widget.liveData();
                    }
                }
            }
            if(state.firstTime == true){
                $("#loading").remove();
                $(".grid-stack").show('fade');
            }
            state.firstTime = false;
            clearInterval(time);
        };

        this.pushAllDatasource = (id, type) => {
            let hasId = false;
            if (type === "web_services") {
                if (state.allDatasource.web_services.length > 0) {
                    state.allDatasource.web_services.map(_id => {
                        if (_id != id) {
                            hasId = false;
                        } else {
                            hasId = true
                        }
                    });
                }
                if (!hasId) {
                    state.allDatasource.web_services.push(id);
                }
            } else if (type === "iot_services") {
                if (state.allDatasource.iot_services.length > 0) {
                    state.allDatasource.iot_services.map(_id => {
                        if (_id != id) {
                            hasId = false;
                        } else {
                            hasId = true
                        }
                    });
                }
                if (!hasId) {
                    state.allDatasource.iot_services.push(id)
                }
            }
        }

        let createDashboardInit = async (dashboard) => {
            let obj_widget = null;
            let widgets = null;
            let datasources = null;

            let gridData = null;
            let type = "";


            dashboard.map((data, key) => {
                obj_widget = null;
                widgets = data.widget;

                datasources = data.widget.datasources;

                if (datasources) {
                    datasources.map(_d => {
                        this.pushAllDatasource(_d.id, _d.type);
                    });
                }

                gridData = {
                    x: data.x,
                    y: data.y,
                    width: data.width,
                    height: data.height,
                };

                type = widgets.type;
                widgets.lastUpdate = getDateTimeNow();
                if (type === WIDGET_TYPE.MUTILINE) {
                    obj_widget = new MutiLine(widgets, gridData);
                } else if (type === WIDGET_TYPE.MUTILINE_STATIC) {
                    obj_widget = new MutiLineStatic(widgets, gridData);
                } else if (type === WIDGET_TYPE.GAUGES) {
                    obj_widget = new Gauges(widgets, gridData);
                } else if (type === WIDGET_TYPE.RADAR) {
                    obj_widget = new Radar(widgets, gridData);
                } else if (type === WIDGET_TYPE.TEXTLINE) {
                    obj_widget = new ChartTextLine(widgets, gridData);
                } else if (type === WIDGET_TYPE.MAP) {
                    obj_widget = new Map(widgets, gridData);
                } else if (type === WIDGET_TYPE.TABLE) {
                    obj_widget = new Table(widgets, gridData);
                } else if (type === WIDGET_TYPE.TEXTVALUE) {
                    obj_widget = new TextValue(widgets, gridData);
                } else if (type === WIDGET_TYPE.TEXTBOX) {
                    obj_widget = new TextBox(widgets, gridData);
                }

                if (obj_widget !== null) {
                    widgetList.push(obj_widget);
                }
            })

            for (let i = 0; i < state.allDatasource.web_services.length; i++) {
                await Datasource.getFirstApi(state.allDatasource.web_services[i], "web_services");
            }

            for (let i = 0; i < state.allDatasource.iot_services.length; i++) {
                await Datasource.getFirstApi(state.allDatasource.iot_services[i], "iot_services");
            }


           socket_dashboards.emit('update-datasources', state.allDatasource);

            $(".edit-widget").hide();

        };


        this.initDashboard = async () => {
            Datasource = new Datasources();

            let dashboard = "";
            // set widget $.ajax
            await Datasource.initCreate();

            await $.ajax({
                url: END_POINT + API.getStatic + $("#static_id").html(),
                method: 'GET',
                success: (res, textStatus, xhr) => {
                    console.log(res);
                    if (res.data) {
                        dashboard = GridStackUI.Utils.sort(JSON.parse(res.data.dashboard));
                    }
                },
                error: (res) => {
                    console.log(res);
                }
            });

            await createDashboardInit(dashboard);

            $(".grid-stack").gridstack(options);
            grid = $(".grid-stack").data("gridstack");
            grid.enableMove(false);
            grid.enableResize(false);

            await updateDatalast();

            bindElement();
        };
    }

    static diffTime(lastUpdate, timeInterval = 0) {
        //console.log(lastUpdate);
        let current = new Date();
        let _lastUpdate = new Date(lastUpdate);

        let diff = (current.getTime() - _lastUpdate.getTime()) / 1000;
        //หน่วยวินาที
        // diff /= 60;

        return Math.abs(Math.round(diff));
    }

    static updateGridData(id) {

    }

    static getWidgetById(itemId) {
        return widgetList.find(widget => {
            return widget.itemId == itemId;
        });
    }
}

$(document).ready(function () {
    socket_dashboards = io(`${WS_URL}dashboardsPublic`,{transports: ['websocket']});

    socket_dashboards.on('connect', function (data) {

    });

    socket_dashboards.on('disconnect', function (data) {

    });

    $("#sidebarCollapse").click();
    state.dashboard = new Dashboard();
    state.dashboard.initDashboard();

    $('.grid-stack').on('gsresizestop', function (event, elem) {
        let el = $(elem);
        let data_widget = JSON.parse(el.data('_gridstack_data'));
        let node = el.data('_gridstack_node');
        let type = data_widget.type;
        if (type === "Gauges") {} else if (type === "MutiLine") {
            let element = event.target;
            let width = el.find('.card-body').width();
            let height = el.find('.card-body').height();
            let panel = el.find('.card-body');
            let id = $(panel).find('canvas');

            // var canvas = document.getElementById($(id).attr('id'));
            // canvas.toBlob(function (blob) {
            //     saveAs(blob, "pretty image.png");
            // });
        } else if (type === "Map") {
            let map = Dashboard.getWidgetById(node.id);
            map.myMap.invalidateSize();
        }
    });

});
