import {
    LOADING,
    convertHex,
    getRndInteger
} from '../../utility.js';

const END_POINT = 'http://localhost:8000/api/';

class Cluster {
    constructor() {
        let el = {
            number_of_clusters: $("#number_of_clusters"),
            method: $("#method"),
            max_candidates: $("#max_candidates"),
            min_density: $("#min_density"),
        }

        this.type = 'cluster';
        this.number_of_clusters = el.number_of_clusters.val();
        this.method = el.method.val();
        this.max_candidates = el.max_candidates.val();
        this.min_density = el.min_density.val();

        let self = this;


        this.bindElement = () => {
            el.number_of_clusters.change(function () {
                self.number_of_clusters = $(this).val();
            });

            el.method.change(function () {
                self.method = $(this).val();
            });

            el.max_candidates.change(function () {
                self.max_candidates = $(this).val();
            });


            el.min_density.change(function () {
                self.min_density = $(this).val();
            });
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_clusters: this.number_of_clusters,
                method: this.method,
                max_candidates: this.max_candidates,
                min_density: this.min_density,
            }
        }
    }
}

class Associate {
    constructor() {
        let el = {
            number_of_rules: $("#number_of_rules"),
            metric_type: $("#metric_type"),
            minimum_confidence: $("#minimum_confidence"),
            delta_for_minimum_support: $("#delta_for_minimum_support"),
            upper_for_minimum_support: $("#upper_for_minimum_support"),
            lower_for_minimum_support: $("#lower_for_minimum_support"),
        }

        this.type = 'associate';
        this.number_of_rules = el.number_of_rules.val();
        this.metric_type = el.metric_type.val();
        this.minimum_confidence = el.minimum_confidence.val();
        this.delta_for_minimum_support = el.delta_for_minimum_support.val();
        this.upper_for_minimum_support = el.upper_for_minimum_support.val();
        this.lower_for_minimum_support = el.lower_for_minimum_support.val();

        let self = this;

        this.bindElement = () => {
            el.number_of_rules.change(function () {
                self.number_of_rules = $(this).val();
            });

            el.metric_type.change(function () {
                self.metric_type = $(this).val();
            });

            el.minimum_confidence.change(function () {
                self.minimum_confidence = $(this).val();
            });

            el.delta_for_minimum_support.change(function () {
                self.delta_for_minimum_support = $(this).val();
            });

            el.upper_for_minimum_support.change(function () {
                self.upper_for_minimum_support = $(this).val();
            });

            el.lower_for_minimum_support.change(function () {
                self.lower_for_minimum_support = $(this).val();
            });
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_rules: this.number_of_rules,
                metric_type: this.metric_type,
                minimum_confidence: this.minimum_confidence,
                delta_for_minimum_support: this.delta_for_minimum_support,
                upper_for_minimum_support: this.upper_for_minimum_support,
                lower_for_minimum_support: this.lower_for_minimum_support,
            }
        }
    }
}

class J48 {
    constructor() {
        let el = {
            confidence_threshold: $("#confidence_threshold"),
            minimum_number_of_instances: $("#minimum_number_of_instances"),
            number_of_folds: $("#number_of_folds"),
        }

        this.type = 'J48';
        this.confidence_threshold = el.confidence_threshold.val();
        this.minimum_number_of_instances = el.minimum_number_of_instances.val();
        this.number_of_folds = el.number_of_folds.val();

        let self = this;

        this.bindElement = () => {
            el.confidence_threshold.change(function () {
                self.confidence_threshold = $(this).val();
            });

            el.minimum_number_of_instances.change(function () {
                self.minimum_number_of_instances = $(this).val();
            });

            el.number_of_folds.change(function () {
                self.number_of_folds = $(this).val();
            })
        }

        this.getValue = () => {
            return {
                type: this.type,
                confidence_threshold: this.confidence_threshold,
                minimum_number_of_instances: this.minimum_number_of_instances,
                number_of_folds: this.number_of_folds,
            }
        }
    }
}

let state = {
    tabSelect: 'classify-tab',
    outputCluster: null,
    axis_x : 0,
    axis_y : 0
};

class Visualize {
    constructor() {
        let el = {
            axis_x: $("#axis_x"),
            axis_y: $("#axis_y"),
        }
        let axis_x = el.axis_x.val();
        let axis_y = el.axis_y.val();
        let scatter_chart = null;

        let colors = [
            '#E53935',
            '#1E88E5',
            '#43A047',
            '#FB8C00',
            '#28a745',
            '#ffc107',
            '#17a2b8',
            '#fd7e14',
            '#6610f2',
            '#dc3545',
        ];



        let instance_number = [];

        let self = this;

        let clusters = null;

        let optionsChart = {
            responsive: true,

        };

        let createScatterChart = () => {
            if (scatter_chart === null) {
                let ctx = document.getElementById("scatter_chart").getContext('2d');
                scatter_chart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{}]
                    },
                    options: optionsChart
                });
            } else {
                scatter_chart.data.datasets = [{}];
                scatter_chart.update();
            }
            el.axis_x.change();
        }



        let updataChart = () => {
            if (scatter_chart != null) {
                let data = [];

                let keyCluster = Object.keys(clusters);
                for (let i = 0; i < keyCluster.length; i++) {
                    let obj = [];
                    clusters[keyCluster[i]].map(_data => {
                        obj.push({
                            x: _data.values[state.axis_x],
                            y: _data.values[state.axis_y],
                        })
                    })
                    data.push(obj);
                }

                for (let i = 0; i < data.length; i++) {

                    for (let j = 0; j < data[i].length; j++) {
                        if (isNaN(data[i][j].x)) {
                            for (let x = 0; x < state.outputCluster.header.attributes[state.axis_x].labels.length; x++) {

                                if (data[i][j].x === state.outputCluster.header.attributes[state.axis_x].labels[x]) {
                                    data[i][j].x = x;
                                }
                            }
                        } else {
                            data[i][j].x = parseFloat(data[i][j].x);
                        }

                        if (isNaN(data[i][j].y)) {
                            for (let y = 0; y < state.outputCluster.header.attributes[state.axis_y].labels.length; y++) {

                                if (data[i][j].y === state.outputCluster.header.attributes[state.axis_y].labels[y]) {
                                    data[i][j].y = y;
                                }
                            }
                        } else {
                            data[i][j].y = parseFloat(data[i][j].y);
                        }
                    }

                }

                let datasets = [];
                data.map((_data, index) => {
                    let ran = getRndInteger(5, 15);
                    datasets.push({
                        label: 'Cluster' + index,
                        data: _data,
                        pointHoverRadius: ran,
                        pointRadius: ran,
                        borderColor: colors[index],
                        backgroundColor: convertHex(colors[index], 40),
                    })
                });

                scatter_chart.data.datasets = datasets;
                scatter_chart.update();

                let optionsChart = {
                    responsive: true,
                    scales: {
                        xAxes: [{
                            ticks: {
                                // Include a dollar sign in the ticks
                                callback: function (value, index) {
                                    if (state.outputCluster.header.attributes[state.axis_x].type !== "numeric") {
                                        return state.outputCluster.header.attributes[state.axis_x].labels[value];
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }],
                        yAxes: [{
                            ticks: {
                                // Include a dollar sign in the ticks
                                callback: function (value, index) {
                                    if (state.outputCluster.header.attributes[state.axis_y].type !== "numeric") {
                                        return state.outputCluster.header.attributes[state.axis_y].labels[value];
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }]
                    }

                };
                scatter_chart.options = optionsChart;
                scatter_chart.update();
            }

        }

        this.bindElement = () => {
            el.axis_x.change(function () {
                state.axis_x = $(this).val();
                if (scatter_chart != null) {
                    updataChart();
                }

            });

            el.axis_y.change(function () {
                state.axis_y = $(this).val();
                if (scatter_chart != null) {
                    updataChart();
                }

            })
        }

        this.createAxis = (output) => {
            state.outputCluster = output.outputCluster;
            let html = "";
            output.outputCluster.header.attributes.map((attr, index) => {
                html += `<option value="${index}">${attr.name}</option>`;
            });

            el.axis_x.html(html);
            el.axis_y.html(html);

            for (let i = 0; i < output.outputCluster.data.length; i++) {
                instance_number.push(i);
            }

            clusters = _.groupBy(output.outputCluster.data, d => d.values[d.values.length - 1]);

            createScatterChart();

        }


    }
}

class Analysis {
    constructor() {
        let cluster = new Cluster();
        let associate = new Associate();
        let visualize = new Visualize();
        let j48 = new J48();

        let traningFile = null;
        let output = null;
        let traningFileSelect = "";

        let bindElement = () => {
            $("#btn_process").unbind().click(function () {
                analysisProcess();
            });

            $(".tab-basic .nav-link").unbind().click(function () {
                $("#outputText").html('');
                $(".result").hide();
                state.tabSelect = $(this).attr('id');
                d3.select('#graph').selectAll('svg').remove();
                $("#visualize").hide();
            });

            $("#training_file").change(function () {
                traningFileSelect = $(this).val();
            });
        }

        let writeOutputText = () => {
            let outputText = output.outputText;
            let textarea = "";
            outputText.map(text => {
                textarea += text + "\n";
            });
            $(".result").show();
            $("#outputText").html(textarea);
            if (output.tree) {
                d3.select("#graph").graphviz()
                    .fade(false)
                    .renderDot(output.tree);
            }

            if (output.outputCluster) {
                $("#visualize").show();
                visualize.createAxis(output);
            } else {
                $("#visualize").hide();
            }
        }



        let analysisProcess = () => {
            let data = {};
            let dataInput = null;

            if (state.tabSelect === 'cluster-tab') {
                dataInput = cluster.getValue();
            } else if (state.tabSelect === 'associate-tab') {
                dataInput = associate.getValue();
            } else if (state.tabSelect === 'classify-tab') {
                dataInput = j48.getValue();
            }

            data = {
                type: dataInput.type,
                traningFile: traningFileSelect,
                param: dataInput,
            }

            LOADING.set($("#btn_process"));
            d3.select('#graph').selectAll('svg').remove();
            $.ajax({
                url: END_POINT + 'company/analysis',
                method: 'POST',
                data: data,
                success: (res) => {
                    output = res.data;
                    console.log(output);
                    writeOutputText();
                    LOADING.reset($("#btn_process"));
                },
                error: (res) => {
                    console.log(res);
                    LOADING.reset($("#btn_process"));
                }
            });
        }

        let createSelectTraningFile = () => {
            let html = "<option value=''>--Select training file--</option>";
            traningFile.map(file => {
                html += `<option value="${file.data_id}">${file.name}</option>`;
            });
            $("#training_file").html(html);
        }

        let getTraningFile = () => {
            $.ajax({
                url: END_POINT + 'company/analysis/data',
                success: (res) => {
                    traningFile = res.data;
                    console.log(traningFile)
                    createSelectTraningFile();
                },
                error: (res) => {
                    console.log(res)
                }
            })
        };

        this.initAndRun = () => {
            bindElement();
            cluster.bindElement();
            associate.bindElement();
            visualize.bindElement();
            getTraningFile();
        }
    }
}

$(document).ready(function () {
    let analysis = new Analysis();
    analysis.initAndRun();
});
