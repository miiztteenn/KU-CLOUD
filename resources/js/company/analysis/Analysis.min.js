import {
    LOADING
} from '../../utility.js';

const END_POINT = 'http://localhost:8000/api/';

class Cluster {
    constructor() {
        let el = {
            number_of_clusters: $("#number_of_clusters"),
            method: $("#method"),
            max_candidates: $("#max_candidates"),
            min_density: $("#min_density"),
        }

        this.type = 'cluster';
        this.number_of_clusters = el.number_of_clusters.val();
        this.method = el.method.val();
        this.max_candidates = el.max_candidates.val();
        this.min_density = el.min_density.val();

        let self = this;


        this.bindElement = () => {
            el.number_of_clusters.change(function () {
                self.number_of_clusters = $(this).val();
            });

            el.method.change(function () {
                self.method = $(this).val();
            });

            el.max_candidates.change(function () {
                self.max_candidates = $(this).val();
            });


            el.min_density.change(function () {
                self.min_density = $(this).val();
            });
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_clusters: this.number_of_clusters,
                method: this.method,
                max_candidates: this.max_candidates,
                min_density: this.min_density,
            }
        }
    }
}

class Associate {
    constructor(){
        let el = {
            number_of_rules : $("#number_of_rules"),
            metric_type : $("#metric_type"),
            minimum_confidence : $("#minimum_confidence"),
            delta_for_minimum_support : $("#delta_for_minimum_support"),
            upper_for_minimum_support : $("#upper_for_minimum_support"),
            lower_for_minimum_support : $("#lower_for_minimum_support"),
        }

        this.type = 'associate';
        this.number_of_rules = el.number_of_rules.val();
        this.metric_type = el.metric_type.val();
        this.minimum_confidence = el.minimum_confidence.val();
        this.delta_for_minimum_support = el.delta_for_minimum_support.val();
        this.upper_for_minimum_support = el.upper_for_minimum_support.val();
        this.lower_for_minimum_support = el.lower_for_minimum_support.val();

        let self = this;

        this.bindElement = () => {
            el.number_of_rules.change(function(){
                self.number_of_rules = $(this).val();
            });

            el.metric_type.change(function(){
                self.metric_type = $(this).val();
            });

            el.minimum_confidence.change(function(){
                self.minimum_confidence = $(this).val();
            });

            el.delta_for_minimum_support.change(function(){
                self.delta_for_minimum_support = $(this).val();
            });

            el.upper_for_minimum_support.change(function(){
                self.upper_for_minimum_support = $(this).val();
            });

            el.lower_for_minimum_support.change(function(){
                self.lower_for_minimum_support = $(this).val();
            });
        }

        this.getValue = () => {
            return {
                type : this.type,
                number_of_rules : this.number_of_rules,
                metric_type : this.metric_type,
                minimum_confidence : this.minimum_confidence,
                delta_for_minimum_support : this.delta_for_minimum_support,
                upper_for_minimum_support : this.upper_for_minimum_support,
                lower_for_minimum_support : this.lower_for_minimum_support,
            }
        }
    }
}

class J48 {
    constructor(){
        let el = {
            confidence_threshold : $("#confidence_threshold"),
            minimum_number_of_instances : $("#minimum_number_of_instances"),
            number_of_folds : $("#number_of_folds"),
        }

        this.type = 'J48';
        this.confidence_threshold = el.confidence_threshold.val();
        this.minimum_number_of_instances = el.minimum_number_of_instances.val();
        this.number_of_folds = el.number_of_folds.val();

        let self = this;
        
        this.bindElement = () => {
            el.confidence_threshold.change(function(){
                self.confidence_threshold = $(this).val();
            });

            el.minimum_number_of_instances.change(function(){
                self.minimum_number_of_instances = $(this).val();
            });

            el.number_of_folds.change(function(){
                self.number_of_folds = $(this).val();
            })
        }

        this.getValue = () =>{
            return {
                type : this.type,
                confidence_threshold : this.confidence_threshold,
                minimum_number_of_instances : this.minimum_number_of_instances,
                number_of_folds : this.number_of_folds,
            }
        }
    }
}

let state = {
    tabSelect: 'cluster-tab'
};

class Analysis {
    constructor() {
        let cluster = new Cluster();
        let associate = new Associate();
        let j48 = new J48();

        let traningFile = null;
        let output = null;
        let traningFileSelect = "";

        let bindElement = () => {
            $("#btn_process").unbind().click(function () {
                analysisProcess();
            });

            $(".tab-basic .nav-link").unbind().click(function () {
                $("#outputText").html('');
                $(".result").hide();
                state.tabSelect = $(this).attr('id');
                d3.select('#graph').selectAll('svg').remove();
            });

            $("#training_file").change(function () {
                traningFileSelect = $(this).val();
            });
        }

        let writeOutputText = () => {
            let outputText = output.outputText;
            let textarea = "";
            outputText.map(text => {
                textarea += text + "\n";
            });
            $(".result").show();
            $("#outputText").html(textarea);
            if(output.tree){
                d3.select("#graph").graphviz()
                .fade(false)
                .renderDot(output.tree);
            }
        }

        let analysisProcess = () => {
            let data = {};
            let dataInput = null;

            if (state.tabSelect === 'cluster-tab') {
                dataInput = cluster.getValue();
            }
            else if(state.tabSelect === 'associate-tab'){
                dataInput = associate.getValue();
            }
            else if(state.tabSelect === 'classify-tab'){
                dataInput = j48.getValue();
            }

            data = {
                type: dataInput.type,
                traningFile: traningFileSelect,
                param: dataInput,
            }
  
            LOADING.set($("#btn_process"));
            d3.select('#graph').selectAll('svg').remove();
            $.ajax({
                url: END_POINT + 'company/analysis',
                method: 'POST',
                data: data,
                success: (res) => {
                    output = res.data;
                    writeOutputText();
                    LOADING.reset($("#btn_process"));

                },
                error: (res) => {
                    console.log(res);
                    LOADING.reset($("#btn_process"));
                }
            });
        }

        let createSelectTraningFile = () => {
            let html = "<option value=''>--Select training file--</option>";
            traningFile.map(file => {
                html += `<option value="${file.data_id}">${file.name}</option>`;
            });
            $("#training_file").html(html);
        }

        let getTraningFile = () => {
            $.ajax({
                url: END_POINT + 'company/analysis/data',
                success: (res) => {
                    traningFile = res.data;
                    console.log(traningFile)
                    createSelectTraningFile();
                },
                error: (res) => {
                    console.log(res)
                }
            })
        };

        this.initAndRun = () => {
            bindElement();
            cluster.bindElement();
            associate.bindElement();
            getTraningFile();
        }
    }
}

$(document).ready(function () {
    let analysis = new Analysis();
    analysis.initAndRun();
});
