import {
    LOADING,
    convertHex,
    randomHexColor,
    getRndInteger,
    deepCopy,
    checkAuthRes
} from '../../utility.js';

import FileSaver from 'file-saver';

const END_POINT = 'http://localhost:8000/api/';

const API = {
    getDataById: 'analysis/data/',
    analysisProcess: "analysis",
    getTraningFile: "analysis/data",
};

class Regression {
    constructor() {
        let el = {
            number_of_folds: $("#number_of_folds"),
            random_number_seed: $("#random_number_seed"),
        }

        this.type = 'regression';
        this.number_of_folds = el.number_of_folds.val();
        this.random_number_seed = el.random_number_seed.val();

        let chart_linear = null;

        let self = this;

        this.bindElement = () => {
            el.number_of_folds.change(function () {
                self.number_of_folds = $(this).val();
            });

            el.random_number_seed.change(function () {
                self.random_number_seed = $(this).val();
            })
        };

        this.writeOutput = (output) => {
            let outputHtml = "";
            let cross_validation = output.cross_validation.value;
            outputHtml = `<h4>${output.linear_regression.header}</h4>
                          <p>${output.linear_regression.value}</p>
                          <br>
                          <h4>Cross-validation</h4>
                          <br>
                          <div class="table-responsive">
                            <table class="table table-bordered">
                                <tbody>
                                    <tr>
                                        <td>${cross_validation[0].text}</td>
                                        <td align="right">${cross_validation[0].val} ${cross_validation[0].unit}</td>
                                    </tr>
                                    <tr>
                                        <td>${cross_validation[1].text}</td>
                                        <td align="right">${cross_validation[1].val} ${cross_validation[1].unit}</td>
                                    </tr>
                                    <tr>
                                        <td>${cross_validation[2].text}</td>
                                        <td align="right">${cross_validation[2].val} ${cross_validation[2].unit}</td>
                                    </tr>
                                    <tr>
                                        <td>${cross_validation[3].text}</td>
                                        <td align="right">${cross_validation[3].val} ${cross_validation[3].unit}</td>
                                    </tr>
                                    <tr>
                                        <td>${cross_validation[4].text}</td>
                                        <td align="right">${cross_validation[4].val} ${cross_validation[4].unit}</td>
                                    </tr>
                                    <tr>
                                        <td>${cross_validation[5].text}</td>
                                        <td align="right">${cross_validation[5].val} ${cross_validation[5].unit}</td>
                                    </tr>
                                </tbody>
                            </tabel>
                          </div>
                         `;
            $("#outputHtml").html(outputHtml);

            createChart(output);
        }

        let createChart = (output) => {
            if(chart_linear == null){
            let ctx = document.getElementById("chart_linear").getContext('2d');

            chart_linear = new Chart(ctx, {
                    type : 'line',
                    data: {
                        labels : [],
                        datasets: [
                            {
                                label : "",
                                backgroundColor: 'rgb(255, 255, 255,0)',
                                borderColor: '#2196F3',
                                data: [],
                            }
                        ]
                    },
                    options: {
                        tooltips: {
                            callbacks: {
                                    title: function(tooltipItem, data) {
                                        return data.datasets[0].label
                                    },
                                    label: function(tooltipItem, data) {
                                        console.log(data)
                                        return "x : " + data['datasets'][0]['data'][tooltipItem['index']].x +" , " + "y : " + data['datasets'][0]['data'][tooltipItem['index']].y;
                                    }
                                
                            }
                        },
                        scales: {
                            yAxes: [{
                                scaleLabel: {
                                    display: true,
                                    labelString: 'y-axis'
                                },
                                ticks: {
                                    beginAtZero: true
                                }
                            }],
                            xAxes: [{
                                scaleLabel: {
                                    display: true,
                                    labelString: 'x-axis'
                                },
                                type: 'linear',
                                display: true,
                                position: 'bottom',
                            }],
                        }
                    }
                });
            }
            updateChart(output);
        };

        let updateChart = (output) => {
            chart_linear.data.datasets[0].data = [];

            chart_linear.data.datasets[0].label = output.linear_regression.value;

            chart_linear.data.datasets[0].data.push({
                x : output.plot.max.x,
                y :output.plot.max.y
            });

            chart_linear.data.datasets[0].data.push({
                x : output.plot.min.x,
                y :output.plot.min.y
            });

            chart_linear.update();
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_folds: this.number_of_folds,
                random_number_seed: this.random_number_seed,
            }
        }
    }
}

class Cluster {
    constructor() {
        let el = {
            number_of_clusters: $("#number_of_clusters"),
            method: $("#method"),
            max_candidates: $("#max_candidates"),
            min_density: $("#min_density"),
        }

        this.type = 'cluster';
        this.number_of_clusters = el.number_of_clusters.val();
        this.method = el.method.val();
        this.max_candidates = el.max_candidates.val();
        this.min_density = el.min_density.val();

        let self = this;


        this.bindElement = () => {
            el.number_of_clusters.change(function () {
                self.number_of_clusters = $(this).val();
            });

            el.method.change(function () {
                self.method = $(this).val();
            });

            el.max_candidates.change(function () {
                self.max_candidates = $(this).val();
            });


            el.min_density.change(function () {
                self.min_density = $(this).val();
            });
        };

        let createTableCluster = (finalCluster, clusters) => {
            let table = $("#outputFinalCluster").html(`<table class="table table-bordered table-striped">
                                                        <thead></thead>
                                                        <tbody></tbody>
                                                       </table>`);
            let thead = table.find('thead');
            thead.append(`<tr><th rowspan="4" style="vertical-align : middle;text-align:center;">Attribute</th></tr>`)
            thead.append(`<tr align="center"><th colspan="${clusters+1}">Cluster#</th></tr>`)
            let html = `<tr align="center"><th>Full data</th>`;
            finalCluster[1].map(_data => {
                if (_data !== 'Attribute' && _data !== 'Data' && _data !== 'Full') {
                    html += `<th>${_data}</th>`;
                }
            });
            html += "</tr>";
            thead.append(html);

            html = `<tr align="center">`;
            finalCluster[2].map(_data => {
                html += `<th>${_data}</th>`;
            });
            html += "</tr>";
            thead.append(html);

            let tbody = table.find('tbody');
            for (let i = 3; i < finalCluster.length; i++) {
                tbody.append(`<tr align="center"></tr>`);
                let tr = tbody.find('tr:last');
                let td = "";
                finalCluster[i].map(_data => {
                    td += `<td>${_data}</td>`;
                })
                tr.append(td);
            }


        };

        let createTalbeClusteredInstances = (output) => {
            let html = `<table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Clustered</th>
                                    <th>Instances</th>
                                    <th>Instances (%)</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tody>
                        </table>`
            let table = $("#clustered_instances").html(html);
            let tbody = table.find("tbody");
            let value = "";
            let i = 0;
            output.map(_data => {
                value = "";
                tbody.append('<tr></tr>');
                _data.map(_val => {
                    if (i != 2) {
                        value += `<td>${_val}</td>`;
                    } else {
                        value += `<td  align="right">${_val}</td>`;
                    }
                    i++;
                })
                i = 0;
                tbody.find('tr:last').html(value);
            })
        }

        this.writeOutput = (output) => {
            let clusters = output.clusters;
            let key = Object.keys(clusters);
            key.map(_key => {
                clusters[_key].map(_data => {

                })
            })
            let outputHtml = `
                <p>Number of iterations: ${output.number_of_iterations.value}</p>
                <p>Within cluster sum of squared errors: ${output.within_cluster_sum_of_squared_errors.value}</p>
                <br>
                <h4>Final cluster centroids:</h4>
                <br>
                <div id="outputFinalCluster" class="table-responsive"></div>
                <br>
                <h4>Clustering stats for training data</h4>
                <br>
                <div id="clustered_instances" class="table-responsive"></div>

            `;
            $("#outputHtml").html(outputHtml);
            createTableCluster(output.final_cluster_centroids.value, Object.keys(output.clusters).length)
            createTalbeClusteredInstances(output.clustered_instances.value);
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_clusters: this.number_of_clusters,
                method: this.method,
                max_candidates: this.max_candidates,
                min_density: this.min_density,
            }
        };
    }
}

class Associate {
    constructor() {
        let el = {
            number_of_rules: $("#number_of_rules"),
            metric_type: $("#metric_type"),
            minimum_confidence: $("#minimum_confidence"),
            delta_for_minimum_support: $("#delta_for_minimum_support"),
            upper_for_minimum_support: $("#upper_for_minimum_support"),
            lower_for_minimum_support: $("#lower_for_minimum_support"),
        }

        this.type = 'associate';
        this.number_of_rules = el.number_of_rules.val();
        this.metric_type = el.metric_type.val();
        this.minimum_confidence = el.minimum_confidence.val();
        this.delta_for_minimum_support = el.delta_for_minimum_support.val();
        this.upper_for_minimum_support = el.upper_for_minimum_support.val();
        this.lower_for_minimum_support = el.lower_for_minimum_support.val();

        let self = this;

        this.bindElement = () => {
            el.number_of_rules.change(function () {
                self.number_of_rules = $(this).val();
            });

            el.metric_type.change(function () {
                self.metric_type = $(this).val();
            });

            el.minimum_confidence.change(function () {
                self.minimum_confidence = $(this).val();
            });

            el.delta_for_minimum_support.change(function () {
                self.delta_for_minimum_support = $(this).val();
            });

            el.upper_for_minimum_support.change(function () {
                self.upper_for_minimum_support = $(this).val();
            });

            el.lower_for_minimum_support.change(function () {
                self.lower_for_minimum_support = $(this).val();
            });
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_rules: this.number_of_rules,
                metric_type: this.metric_type,
                minimum_confidence: this.minimum_confidence,
                delta_for_minimum_support: this.delta_for_minimum_support,
                upper_for_minimum_support: this.upper_for_minimum_support,
                lower_for_minimum_support: this.lower_for_minimum_support,
            }
        }

        this.writeOutput = (output) => {
            let outputHtml = `
            <p>Minimum support : ${output.minimum_support.value}</p>
            <p>Minimum metric : ${output.minimum_metric_confidence.value}</p>
            <br>
            <p>Number of cycles performed : ${output.number_of_cycles_performed.value}</p>
            <br>
            <h4>Generated sets of large itemsets:</h4>
            <br>
            <div class="table-responsive">
                <table class="table table-bordered" id="table_itemsets">
                    <tbody>
                    </tbody>
                </table>
            </div>
            <br>
            <h4>Best rules found :</h4>
            <br>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped" id="table_rule">
                        <thead>
                            <tr>
                                <th rowspan="3" style="vertical-align : middle;text-align:center;">Rule No.</th>
                            </tr>
                            <tr align="center">
                                <th colspan="2">Rule</th>
                            </tr>
                            <tr align="center">
                                <th>Left</th>
                                <th>Right</th>
                                <th >lift</th>
                                <th>lev</th>
                                <th>conv</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
            <br>
            <p><b>Elapsed time : </b> ${output.elapsed_time.value}</p>
                
            `
            $("#outputHtml").html(outputHtml);

            let table_itemsets = $("#table_itemsets").find('tbody');
            let generated_sets_of_large_itemsets = output.Generated_sets_of_large_itemsets;
            let key = Object.keys(generated_sets_of_large_itemsets);

            key.map(_key => {
                table_itemsets.append('<tr></tr>');
                let tr = table_itemsets.find('tr:last');
                tr.append(`<td>${generated_sets_of_large_itemsets[_key].text}</td>
                           <td align="right">${generated_sets_of_large_itemsets[_key].value}</td>`);
            })

            let table_rule = $("#table_rule").find('tbody');
            let best_rules_found = output.Best_rules_found;
            key = Object.keys(best_rules_found);

            key.map(_key => {
                table_rule.append('<tr></tr>');
                let tr = table_rule.find('tr:last');
                tr.append(`
                            <td style="vertical-align : middle;text-align:center;">${_key}</td>
                            <td>${best_rules_found[_key].leftRule}</td>
                            <td>${best_rules_found[_key].rightRule}</td>
                            <td align="right">${parseFloat(best_rules_found[_key].lift).toFixed(2)}</td>
                            <td align="right">${parseFloat(best_rules_found[_key].lev).toFixed(2)}</td>
                            <td align="right">${parseFloat(best_rules_found[_key].conv).toFixed(2)}</td>
                           `);
            });


        }
    }
}

class J48 {
    constructor() {
        let el = {
            confidence_threshold: $("#confidence_threshold"),
            minimum_number_of_instances: $("#minimum_number_of_instances"),
            number_of_folds: $("#number_of_folds"),
        }

        this.type = 'J48';
        this.confidence_threshold = el.confidence_threshold.val();
        this.minimum_number_of_instances = el.minimum_number_of_instances.val();
        this.number_of_folds = el.number_of_folds.val();

        let chart_accuracy = null;

        let self = this;

        this.bindElement = () => {
            el.confidence_threshold.change(function () {
                self.confidence_threshold = $(this).val();
            });

            el.minimum_number_of_instances.change(function () {
                self.minimum_number_of_instances = $(this).val();
            });

            el.number_of_folds.change(function () {
                self.number_of_folds = $(this).val();
            })
        }

        this.crateChartAccuracy = (output) => {
            let data = [];
            let className = Object.keys(output.detailed_accuracy_by_class.class);
            className.map(_key => {
                data.push(
                    [
                        parseFloat(output.detailed_accuracy_by_class.tp_rate[_key].value),
                        parseFloat(output.detailed_accuracy_by_class.fp_rate[_key].value),
                        parseFloat(output.detailed_accuracy_by_class.precision[_key].value),
                        parseFloat(output.detailed_accuracy_by_class.recall[_key].value),
                        parseFloat(output.detailed_accuracy_by_class['f-measure'][_key].value),
                        parseFloat(output.detailed_accuracy_by_class.mcc[_key].value),
                        parseFloat(output.detailed_accuracy_by_class.roc_area[_key].value),
                        parseFloat(output.detailed_accuracy_by_class.prc_area[_key].value),
                    ]
                )
            })



            chart_accuracy = null;
            let ctx = document.getElementById("chart_accuracy").getContext('2d');
            chart_accuracy = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ["TP Rate", "FP Rate", "Precision", "Recall", "F-Measure", "MCC", "ROC Area", "PRC Area"],
                    datasets: []
                },
                options: {
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true
                            }
                        }]
                    }
                }
            });

            chart_accuracy.data.datasets = [];

            console.log(data);
            data.map((_data, index) => {
                let backgroundColor = [];
                let borderColor = [];
                let color = randomHexColor();

                _data.map(_d => {
                    backgroundColor.push(convertHex(color, 20));
                    borderColor.push(color);
                })

                chart_accuracy.data.datasets.push({
                    label: output.detailed_accuracy_by_class.class[index].value === null ? 'Avg.' : output.detailed_accuracy_by_class.class[index].value,
                    data: _data.slice(),
                    backgroundColor: backgroundColor.slice(),
                    borderColor: borderColor.slice(),
                    borderWidth: 1
                });
            });

            chart_accuracy.update();
        }

        this.writeOutput = (output) => {
            let confusion_matrix = output.confusion_matrix.join("\r\n");
            let className = Object.keys(output.detailed_accuracy_by_class.class);
            let outHtml = `
            <h4>Classifier model (full training set)</h4>
            <br>
            <h4>J48 pruned tree <i class="fas fa-arrow-down download-file grow" id="download_tree" data-toggle="tooltip" data-placement="top" title="Download tree images"></i></h4>
            <br>
            <div id="graph" style="text-align: center; overflow-y:auto"></div>
            <br>
            <p>Number of Leaves : ${output.j48_pruned_tree.number_of_leaves}</p>
            <p>Size of the tree  : ${output.j48_pruned_tree.size_of_the_tree}</p>
            <br>
            <h4>Stratified cross-validation</h4>
            <br>
            <div class="table-responsive">
                <table class="table table-bordered">
                    <tbody>
                        <tr>
                            <td>Correctly Classified Instances</td>
                            <td>${output.stratified_cross_validation.correctly_classified_instances.value} ${output.stratified_cross_validation.correctly_classified_instances.type} ${output.stratified_cross_validation.correctly_classified_instances.instances}  Instance</td>
                        </tr>
                        <tr>
                            <td>Incorrectly Classified Instances</td>
                            <td>${output.stratified_cross_validation.incorrectly_classified_instances.value} ${output.stratified_cross_validation.incorrectly_classified_instances.type} ${output.stratified_cross_validation.incorrectly_classified_instances.instances} Instance</td>
                        </tr>
                        <tr>
                            <td>Kappa statistic</td>
                            <td>${output.stratified_cross_validation.kappa_statistic.value}</td>
                        </tr>
                        <tr>
                            <td>Mean absolute error</td>
                            <td>${output.stratified_cross_validation.mean_absolute_error.value}</td>
                        </tr>
                        <tr>
                            <td>Root mean squared error</td>
                            <td>${output.stratified_cross_validation.root_mean_squared_error.value}</td>
                        </tr>
                        <tr>
                            <td>Relative absolute error</td>
                            <td>${output.stratified_cross_validation.relative_absolute_error.value} ${output.stratified_cross_validation.relative_absolute_error.type}</td>
                        </tr>
                        <tr>
                            <td>Root relative squared error</td>
                            <td>${output.stratified_cross_validation.root_relative_squared_error.value} ${output.stratified_cross_validation.relative_absolute_error.type}</td>
                        </tr>
                        <tr>
                            <td>Total Number of Instances</td>
                            <td>${output.stratified_cross_validation.total_number_of_instances.value}</td>
                        </tr>
                    </tbody>
                <table>
            </div>
            <br>
            <h4>Detailed Accuracy By Class</h4>
            <br>
            <canvas id="chart_accuracy" style="height:200px"></canvas>
            <br>
            <div class="table-responsive">
                <table class="table table-bordered" id="accuracy_by_class">
                    <thead>
                        <tr>
                            <th></th>
                            <th>TP Rate <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FN )"></i></th>
                            <th>FP Rate <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="FP / ( FP + TN )"></i></th>
                            <th>Precision <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FP )"></i></th>
                            <th>Recall <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FN )"></i></th>
                            <th>F-Measure <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content=" 2 x Precision x Recall / (Precision + Recall)"></i></th>
                            <th>MCC</th>
                            <th>ROC Area</th>
                            <th>PRC Area</th>
                            <th>Class</th>
                        <tr>
                    </thead>
                    <tbody>

                    </tbody>
                </table>
            </div>
            <br>
            <h4>Confusion Matrix</h4>
            <pre>${confusion_matrix}</pre>
            `;
            $("#outputHtml").html(outHtml);

            let table = $("#accuracy_by_class");
            let tbody = table.find('tbody');
            className.map((_class, index) => {
                tbody.append('<tr></tr>');
                let tr = tbody.find('tr:last');
                console.log(tr);
                tr.html(`   <td>${index+1 === className.length ? 'Weighted Avg.' : ''}</td>
                            <td>${output.detailed_accuracy_by_class.tp_rate[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.fp_rate[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.precision[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.recall[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class['f-measure'][_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.mcc[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.roc_area[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.prc_area[_class].value}</td>
                            <td>${output.detailed_accuracy_by_class.class[_class].value == null ? '' : output.detailed_accuracy_by_class.class[_class].value}</td>`)

            })

            $('[data-toggle="popover"]').popover({
                trigger: "hover",
                html: true,
            })

            $('[data-toggle="tooltip"]').tooltip();

            $("#download_tree").unbind().click(function () {
                let target = document.getElementById("graph");

                html2canvas(target).then(canvas => {
                    saveAs(canvas.toDataURL(), 'file-name.png');
                });
            });

            d3.select("#graph").graphviz()
                .fade(false)
                .renderDot(output.tree);
            this.crateChartAccuracy(output);
        }

        this.getValue = () => {
            return {
                type: this.type,
                confidence_threshold: this.confidence_threshold,
                minimum_number_of_instances: this.minimum_number_of_instances,
                number_of_folds: this.number_of_folds,
            }
        }
    }
}

let state = {
    tabSelect: 'classify-tab',
    outputCluster: null,
    axis_x: 0,
    axis_y: 0
};

class Visualize {
    constructor() {
        let el = {
            axis_x: $("#axis_x"),
            axis_y: $("#axis_y"),
        }
        let axis_x = el.axis_x.val();
        let axis_y = el.axis_y.val();
        let scatter_chart = null;

        let colors = [
            '#E53935',
            '#1E88E5',
            '#43A047',
            '#FB8C00',
            '#28a745',
            '#ffc107',
            '#17a2b8',
            '#fd7e14',
            '#6610f2',
            '#dc3545',
        ];



        let instance_number = [];

        let self = this;

        let clusters = null;

        let optionsChart = {
            responsive: true,

        };

        let createScatterChart = () => {
            if (scatter_chart === null) {
                let ctx = document.getElementById("scatter_chart").getContext('2d');
                scatter_chart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{}]
                    },
                    options: optionsChart
                });
            } else {
                scatter_chart.data.datasets = [{}];
                scatter_chart.update();
            }
            el.axis_x.change();
        }



        let updataChart = () => {
            if (scatter_chart != null) {
                let data = [];

                let keyCluster = Object.keys(clusters);
                for (let i = 0; i < keyCluster.length; i++) {
                    let obj = [];
                    clusters[keyCluster[i]].map(_data => {
                        obj.push({
                            x: _data.values[state.axis_x],
                            y: _data.values[state.axis_y],
                        })
                    })
                    data.push(obj);
                }

                for (let i = 0; i < data.length; i++) {

                    for (let j = 0; j < data[i].length; j++) {
                        if (isNaN(data[i][j].x)) {
                            for (let x = 0; x < state.outputCluster.header.attributes[state.axis_x].labels.length; x++) {

                                if (data[i][j].x === state.outputCluster.header.attributes[state.axis_x].labels[x]) {
                                    data[i][j].x = x;
                                }
                            }
                        } else {
                            data[i][j].x = parseFloat(data[i][j].x);
                        }

                        if (isNaN(data[i][j].y)) {
                            for (let y = 0; y < state.outputCluster.header.attributes[state.axis_y].labels.length; y++) {

                                if (data[i][j].y === state.outputCluster.header.attributes[state.axis_y].labels[y]) {
                                    data[i][j].y = y;
                                }
                            }
                        } else {
                            data[i][j].y = parseFloat(data[i][j].y);
                        }
                    }

                }

                let datasets = [];
                data.map((_data, index) => {
                    let ran = getRndInteger(5, 15);
                    datasets.push({
                        label: 'Cluster' + index,
                        data: _data,
                        pointHoverRadius: ran,
                        pointRadius: ran,
                        borderColor: colors[index],
                        backgroundColor: convertHex(colors[index], 40),
                    })
                });

                scatter_chart.data.datasets = datasets;
                scatter_chart.update();

                let optionsChart = {
                    responsive: true,
                    scales: {
                        xAxes: [{
                            ticks: {
                                // Include a dollar sign in the ticks
                                callback: function (value, index) {
                                    if (state.outputCluster.header.attributes[state.axis_x].type !== "numeric") {
                                        return state.outputCluster.header.attributes[state.axis_x].labels[value];
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }],
                        yAxes: [{
                            ticks: {
                                // Include a dollar sign in the ticks
                                callback: function (value, index) {
                                    if (state.outputCluster.header.attributes[state.axis_y].type !== "numeric") {
                                        return state.outputCluster.header.attributes[state.axis_y].labels[value];
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }]
                    }

                };
                scatter_chart.options = optionsChart;
                scatter_chart.update();
            }

        }

        this.bindElement = () => {
            el.axis_x.change(function () {
                state.axis_x = $(this).val();
                if (scatter_chart != null) {
                    updataChart();
                }

            });

            el.axis_y.change(function () {
                state.axis_y = $(this).val();
                if (scatter_chart != null) {
                    updataChart();
                }

            })
        }

        this.createAxis = (output) => {
            state.outputCluster = output.outputCluster;
            let html = "";
            output.outputCluster.header.attributes.map((attr, index) => {
                html += `<option value="${index}">${attr.name}</option>`;
            });

            el.axis_x.html(html);
            el.axis_y.html(html);

            for (let i = 0; i < output.outputCluster.data.length; i++) {
                instance_number.push(i);
            }

            clusters = _.groupBy(output.outputCluster.data, d => d.values[d.values.length - 1]);

            createScatterChart();

        }


    }
}

class Analysis {
    constructor() {
        let cluster = new Cluster();
        let associate = new Associate();
        let visualize = new Visualize();
        let regression = new Regression();
        let j48 = new J48();

        let traningFile = null;
        let output = null;
        let traningFileSelect = "";

        let dataTable = null;
        let datasources = {};
        let data = null;

        let createTableData = () => {
            dataTable = $("#dataTable");
            let thead = dataTable.find('thead');
            thead.empty();
            let tbody = dataTable.find('tbody');
            tbody.empty();
            thead.append('<tr></tr>');
            let tr = thead.find('tr:last');
            tr.append(`<th>#</th>`);
            data.data.header.attributes.map(_data => {
                tr.append(`<th>${_data.name}</th>`);
            });

            data.data.data.map((_data, index) => {
                tbody.append('<tr></tr>');
                let tr = tbody.find('tr:last');
                tr.append(`<td>${index+1}</td>`);
                _data.values.map(_value => {
                    tr.append(`<td>${_value}</td>`);
                })
            });

            dataTable.parent().show();
            dataTable = $('#dataTable').dataTable({});
        }


        let bindElement = () => {

            $("#btn_process").unbind().click(function () {
                analysisProcess();
            });

            // $(".cancel-getFile").unbind().click(function(){
                
            //     $('#dataTable').dataTable().fnDestroy();

            //     if(this.ajaxGetDataById != null){
            //         this.ajaxGetDataById.abort();
            //     }

            //     $(this).hide();
            // });

            $(".tab-basic .nav-link").unbind().click(function () {
                $("#outputText").html('');
                $("#outputHtml").html('');
                $(".result").hide();
                state.tabSelect = $(this).attr('id');
                d3.select('#graph').selectAll('svg').remove();
                $("#visualize").hide();
                $("#chart_regression").hide();
            });

            $("#training_file").change(function () {
                
                traningFileSelect = $(this).val();
                
                if(dataTable != null){
                   
                    $('#dataTable').dataTable().fnDestroy();
                }

                if(this.ajaxGetDataById != null){
                    this.ajaxGetDataById.abort
                }

                dataTable = $("#dataTable");
                dataTable.parent().hide();
                let thead = dataTable.find('thead');
                thead.empty();
                let tbody = dataTable.find('tbody');
                tbody.empty();

                if (traningFileSelect != "" && !datasources[traningFileSelect]) {
                    $(this).prop('disabled',true);
                    //$(".cancel-getFile").show();
                    $("body").find('.lds-roller').show();
                    this.ajaxGetDataById = $.ajax({
                        url: `${END_POINT}${API.getDataById}${traningFileSelect}/json`,
                        method: 'GET',
                        success: (res, textStatus, xhr) => {
                            checkAuthRes(xhr);
                            $("body").find('.lds-roller').hide();
                            data = res.data;
                            datasources[traningFileSelect] = res.data;
                            createTableData();
                            $(this).prop('disabled',false);
                            //$(".cancel-getFile").hide();
                        },
                        error: (res) => {

                        }
                    })
                }
                else if(datasources[traningFileSelect]){
                    data =  datasources[traningFileSelect];
                    createTableData();
                }
            });

            $(".download-file").unbind().click(function () {
                downloadFileResult($(this).attr('type'));
            });
        }

        let downloadFileResult = (type) => {
            if (type === 'text') {
                let blob = new Blob([output.outputText.join("\r\n")], {
                    type: "text/plain;charset=utf-8"
                });
                FileSaver.saveAs(blob, `file_result.txt`);
            } else if (type === 'json') {
                let blob = new Blob([JSON.stringify(output, null, '        ')], {
                    type: "text/plain;charset=utf-8"
                });
                FileSaver.saveAs(blob, `file_result.json`);
            }
            return;
        }

        let writeOutputHtml = () => {
            let outHtml = "";
            if (state.tabSelect === 'cluster-tab') {
                cluster.writeOutput(output);
            } else if (state.tabSelect === 'regression-tab') {
                regression.writeOutput(output);
            } else if (state.tabSelect === 'associate-tab') {
                associate.writeOutput(output);
            } else if (state.tabSelect === 'classify-tab') {
                j48.writeOutput(output);
            }

        }

        let writeOutput = () => {
            let outputText = output.outputText;
            let textarea = "";
            outputText.map(text => {
                textarea += text + "\n";
            });
            $(".result").show();
            $("#outputText").html(textarea);

            if (state.tabSelect === 'cluster-tab') {
                $("#visualize").show();
                visualize.createAxis(output);
            } else if (state.tabSelect === 'classify-tab') {
            
            }
            else if(state.tabSelect === 'regression-tab'){
                $("#chart_regression").show();
            } else {
                $("#visualize").hide();
                $("#chart_regression").hide();
            }
            writeOutputHtml();
        }



        let analysisProcess = () => {
            let data = {};
            let dataInput = null;

            if (state.tabSelect === 'cluster-tab') {
                dataInput = cluster.getValue();
            } else if (state.tabSelect === 'regression-tab') {
                dataInput = regression.getValue();
            } else if (state.tabSelect === 'associate-tab') {
                dataInput = associate.getValue();
            } else if (state.tabSelect === 'classify-tab') {
                dataInput = j48.getValue();
            }

            data = {
                type: dataInput.type,
                traningFile: traningFileSelect,
                param: dataInput,
            }

            LOADING.set($("#btn_process"));
            d3.select('#graph').selectAll('svg').remove();
            $.ajax({
                url: END_POINT + API.analysisProcess,
                method: 'POST',
                data: data,
                success: (res) => {
                    output = res.data;
                    console.log(output);
                    if (output.outputText.length > 0) {
                        writeOutput();
                    }
                    LOADING.reset($("#btn_process"));
                },
                timeout: 30000,
                error: (res) => {
                    console.log(res);
                    LOADING.reset($("#btn_process"));
                }
            });
        }

        let createSelectTraningFile = () => {
            let html = "<option value=''>--Select training file--</option>";
            traningFile.map(file => {
                html += `<option value="${file.data_id}">${file.name}</option>`;
            });
            $("#training_file").html(html);
        }

        let getTraningFile = () => {
            $.ajax({
                url: END_POINT + API.getTraningFile,
                success: (res) => {
                    traningFile = res.data;
                    console.log(traningFile)
                    createSelectTraningFile();
                },
                error: (res) => {
                    console.log(res)
                }
            })
        };

        this.initAndRun = () => {
            bindElement();
            cluster.bindElement();
            regression.bindElement();
            associate.bindElement();
            visualize.bindElement();
            getTraningFile();
        }
    }
}

$(document).ready(function () {
    let analysis = new Analysis();
    analysis.initAndRun();
});
