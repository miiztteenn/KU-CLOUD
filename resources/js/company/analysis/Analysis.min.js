import {
    LOADING,
    convertHex,
    getRndInteger,
    deepCopy
} from '../../utility.js';

import FileSaver  from 'file-saver';

const END_POINT = 'http://localhost:8000/api/';

class Cluster {
    constructor() {
        let el = {
            number_of_clusters: $("#number_of_clusters"),
            method: $("#method"),
            max_candidates: $("#max_candidates"),
            min_density: $("#min_density"),
        }

        this.type = 'cluster';
        this.number_of_clusters = el.number_of_clusters.val();
        this.method = el.method.val();
        this.max_candidates = el.max_candidates.val();
        this.min_density = el.min_density.val();

        let self = this;


        this.bindElement = () => {
            el.number_of_clusters.change(function () {
                self.number_of_clusters = $(this).val();
            });

            el.method.change(function () {
                self.method = $(this).val();
            });

            el.max_candidates.change(function () {
                self.max_candidates = $(this).val();
            });


            el.min_density.change(function () {
                self.min_density = $(this).val();
            });
        };

        let createTableCluster = (finalCluster, clusters) => {
            let table = $("#outputFinalCluster").html(`<table class="table table-bordered table-striped">
                                                        <thead></thead>
                                                        <tbody></tbody>
                                                       </table>`);
            let thead = table.find('thead');
            thead.append(`<tr><th rowspan="4" style="vertical-align : middle;text-align:center;">Attribute</th></tr>`)
            thead.append(`<tr align="center"><th colspan="${clusters+1}">Cluster#</th></tr>`)
            let html = `<tr align="center"><th>Full data</th>`;
            finalCluster[1].map(_data => {
                if (_data !== 'Attribute' && _data !== 'Data' && _data !== 'Full') {
                    html += `<th>${_data}</th>`;
                }
            });
            html += "</tr>";
            thead.append(html);

            html = `<tr align="center">`;
            finalCluster[2].map(_data => {
                html += `<th>${_data}</th>`;
            });
            html += "</tr>";
            thead.append(html);

            let tbody = table.find('tbody');
            for (let i = 3; i < finalCluster.length; i++) {
                tbody.append(`<tr align="center"></tr>`);
                let tr = tbody.find('tr:last');
                let td = "";
                finalCluster[i].map(_data => {
                    td += `<td>${_data}</td>`;
                })
                tr.append(td);
            }


        };

        let createTalbeClusteredInstances = (output) => {
            let html = `<table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Clustered</th>
                                    <th>Instances</th>
                                    <th>Instances (%)</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tody>
                        </table>`
            let table = $("#clustered_instances").html(html);
            let tbody = table.find("tbody");
            let value = "";
            output.map(_data => {
                value = "";
                tbody.append('<tr></tr>');
                _data.map(_val => {
                    value += `<td>${_val}</td>`;
                })
                tbody.find('tr:last').html(value);
            })
        }

        this.writeOutput = (output) => {
            let clusters = output.clusters;
            let key = Object.keys(clusters);
            key.map(_key => {
                clusters[_key].map(_data => {

                })
            }) 
            let outputHtml = `
                <p>Number of iterations: ${output.number_of_iterations.value}</p>
                <p>Within cluster sum of squared errors: ${output.within_cluster_sum_of_squared_errors.value}</p>
                <br>
                <h4>Final cluster centroids:</h4>
                <br>
                <div id="outputFinalCluster" class="table-responsive"></div>
                <br>
                <h4>Clustering stats for training data</h4>
                <br>
                <div id="clustered_instances" class="table-responsive"></div>

            `;
            $("#outputHtml").html(outputHtml);
            createTableCluster(output.final_cluster_centroids.value, Object.keys(output.clusters).length)
            createTalbeClusteredInstances(output.clustered_instances.value);
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_clusters: this.number_of_clusters,
                method: this.method,
                max_candidates: this.max_candidates,
                min_density: this.min_density,
            }
        };
    }
}

class Associate {
    constructor() {
        let el = {
            number_of_rules: $("#number_of_rules"),
            metric_type: $("#metric_type"),
            minimum_confidence: $("#minimum_confidence"),
            delta_for_minimum_support: $("#delta_for_minimum_support"),
            upper_for_minimum_support: $("#upper_for_minimum_support"),
            lower_for_minimum_support: $("#lower_for_minimum_support"),
        }

        this.type = 'associate';
        this.number_of_rules = el.number_of_rules.val();
        this.metric_type = el.metric_type.val();
        this.minimum_confidence = el.minimum_confidence.val();
        this.delta_for_minimum_support = el.delta_for_minimum_support.val();
        this.upper_for_minimum_support = el.upper_for_minimum_support.val();
        this.lower_for_minimum_support = el.lower_for_minimum_support.val();

        let self = this;

        this.bindElement = () => {
            el.number_of_rules.change(function () {
                self.number_of_rules = $(this).val();
            });

            el.metric_type.change(function () {
                self.metric_type = $(this).val();
            });

            el.minimum_confidence.change(function () {
                self.minimum_confidence = $(this).val();
            });

            el.delta_for_minimum_support.change(function () {
                self.delta_for_minimum_support = $(this).val();
            });

            el.upper_for_minimum_support.change(function () {
                self.upper_for_minimum_support = $(this).val();
            });

            el.lower_for_minimum_support.change(function () {
                self.lower_for_minimum_support = $(this).val();
            });
        }

        this.getValue = () => {
            return {
                type: this.type,
                number_of_rules: this.number_of_rules,
                metric_type: this.metric_type,
                minimum_confidence: this.minimum_confidence,
                delta_for_minimum_support: this.delta_for_minimum_support,
                upper_for_minimum_support: this.upper_for_minimum_support,
                lower_for_minimum_support: this.lower_for_minimum_support,
            }
        }

        this.writeOutput = (output) => {
            let outputHtml = `
            <p>Minimum support : ${output.minimum_support.value}</p>
            <p>Minimum metric : ${output.minimum_metric_confidence.value}</p>
            <br>
            <p>Number of cycles performed : ${output.number_of_cycles_performed.value}</p>
            <br>
            <h4>Generated sets of large itemsets:</h4>
            <br>
            <div class="table-responsive">
                <table class="table table-bordered" id="table_itemsets">
                    <tbody>
                    </tbody>
                </table>
            </div>
            <br>
            <h4>Best rules found :</h4>
            <br>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped" id="table_rule">
                        <thead>
                            <tr>
                                <th rowspan="3" style="vertical-align : middle;text-align:center;">Rule No.</th>
                            </tr>
                            <tr align="center">
                                <th colspan="2">Rule</th>
                            </tr>
                            <tr align="center">
                                <th>Left</th>
                                <th>Right</th>
                                <th >lift</th>
                                <th>lev</th>
                                <th>conv</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
            <br>
            <p><b>Elapsed time : </b> ${output.elapsed_time.value}</p>
                
            `
            $("#outputHtml").html(outputHtml);

            let table_itemsets = $("#table_itemsets").find('tbody');
            let generated_sets_of_large_itemsets = output.Generated_sets_of_large_itemsets;
            let key = Object.keys(generated_sets_of_large_itemsets);
            
            key.map(_key => {
                table_itemsets.append('<tr></tr>');
                let tr = table_itemsets.find('tr:last');
                tr.append(`<td>${generated_sets_of_large_itemsets[_key].text}</td>
                           <td>${generated_sets_of_large_itemsets[_key].value}</td>`);
            })

            let table_rule = $("#table_rule").find('tbody');
            let best_rules_found = output.Best_rules_found;
            key = Object.keys(best_rules_found);

            key.map(_key => {
                table_rule.append('<tr></tr>');
                let tr = table_rule.find('tr:last');
                tr.append(`
                            <td style="vertical-align : middle;text-align:center;">${_key}</td>
                            <td>${best_rules_found[_key].leftRule}</td>
                            <td>${best_rules_found[_key].rightRule}</td>
                            <td>${best_rules_found[_key].lift}</td>
                            <td>${best_rules_found[_key].lev}</td>
                            <td>${best_rules_found[_key].conv}</td>
                           `);
            });

             
        }
    }
}

class J48 {
    constructor() {
        let el = {
            confidence_threshold: $("#confidence_threshold"),
            minimum_number_of_instances: $("#minimum_number_of_instances"),
            number_of_folds: $("#number_of_folds"),
        }

        this.type = 'J48';
        this.confidence_threshold = el.confidence_threshold.val();
        this.minimum_number_of_instances = el.minimum_number_of_instances.val();
        this.number_of_folds = el.number_of_folds.val();

        let chart_accuracy = null;

        let self = this;

        this.bindElement = () => {
            el.confidence_threshold.change(function () {
                self.confidence_threshold = $(this).val();
            });

            el.minimum_number_of_instances.change(function () {
                self.minimum_number_of_instances = $(this).val();
            });

            el.number_of_folds.change(function () {
                self.number_of_folds = $(this).val();
            })
        }

        this.crateChartAccuracy = (output) => {
            let data = [
                [
                    parseFloat(output.detailed_accuracy_by_class.tp_rate[0].value),
                    parseFloat(output.detailed_accuracy_by_class.fp_rate[0].value),
                    parseFloat(output.detailed_accuracy_by_class.precision[0].value),
                    parseFloat(output.detailed_accuracy_by_class.recall[0].value),
                    parseFloat(output.detailed_accuracy_by_class['f-measure'][0].value),
                    parseFloat(output.detailed_accuracy_by_class.mcc[0].value),
                    parseFloat(output.detailed_accuracy_by_class.roc_area[0].value),
                    parseFloat(output.detailed_accuracy_by_class.prc_area[0].value),
                ],
                [
                    parseFloat(output.detailed_accuracy_by_class.tp_rate[1].value),
                    parseFloat(output.detailed_accuracy_by_class.fp_rate[1].value),
                    parseFloat(output.detailed_accuracy_by_class.precision[1].value),
                    parseFloat(output.detailed_accuracy_by_class.recall[1].value),
                    parseFloat(output.detailed_accuracy_by_class['f-measure'][1].value),
                    parseFloat(output.detailed_accuracy_by_class.mcc[1].value),
                    parseFloat(output.detailed_accuracy_by_class.roc_area[1].value),
                    parseFloat(output.detailed_accuracy_by_class.prc_area[1].value),
                ],
                [
                    parseFloat(output.detailed_accuracy_by_class.tp_rate[2].value),
                    parseFloat(output.detailed_accuracy_by_class.fp_rate[2].value),
                    parseFloat(output.detailed_accuracy_by_class.precision[2].value),
                    parseFloat(output.detailed_accuracy_by_class.recall[2].value),
                    parseFloat(output.detailed_accuracy_by_class['f-measure'][2].value),
                    parseFloat(output.detailed_accuracy_by_class.mcc[2].value),
                    parseFloat(output.detailed_accuracy_by_class.roc_area[2].value),
                    parseFloat(output.detailed_accuracy_by_class.prc_area[2].value),
                ]
            ]
            chart_accuracy = null;
            let ctx = document.getElementById("chart_accuracy").getContext('2d');
            chart_accuracy = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ["TP Rate", "FP Rate", "Precision", "Recall", "F-Measure", "MCC", "ROC Area", "PRC Area"],
                    datasets: []
                },
                options: {
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true
                            }
                        }]
                    }
                }
            });

            chart_accuracy.data.datasets = [];
            chart_accuracy.data.datasets.push({
                label: 'Yes',
                data: data[0].slice(),
                backgroundColor: [
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                    'rgba(0, 206, 104, 0.2)',
                ],
                borderColor: [
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                    'rgba(0, 206, 104, 1)',
                ],
                borderWidth: 1
            }, {
                label: 'No',
                data: data[1].slice(),
                backgroundColor: [
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                    'rgba(230,82,81, 0.2)',
                ],
                borderColor: [
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                    'rgba(230,82,81, 1)',
                ],
                borderWidth: 1
            }, {
                label: 'Avg',
                data: data[2].slice(),
                backgroundColor: [
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                    'rgba(30,123,203, 0.2)',
                ],
                borderColor: [
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                    'rgba(30,123,203, 1)',
                ],
                borderWidth: 1
            })
            chart_accuracy.update();
        }

        this.writeOutput = (output) => {
            let confusion_matrix = output.confusion_matrix.join("\r\n");
            let outHtml = `
            <h4>Classifier model (full training set)</h4>
            <br>
            <h4>J48 pruned tree <i class="fas fa-arrow-down download-file grow" id="download_tree" data-toggle="tooltip" data-placement="top" title="Download tree images"></i></h4>
            <br>
            <div id="graph" style="text-align: center;"></div>
            <br>
            <p>Number of Leaves : ${output.j48_pruned_tree.number_of_leaves}</p>
            <p>Size of the tree  : ${output.j48_pruned_tree.size_of_the_tree}</p>
            <br>
            <h4>Stratified cross-validation</h4>
            <br>
            <div class="table-responsive">
                <table class="table table-bordered">
                    <tbody>
                        <tr>
                            <td>Correctly Classified Instances</td>
                            <td>${output.stratified_cross_validation.correctly_classified_instances.value} ${output.stratified_cross_validation.correctly_classified_instances.type} ${output.stratified_cross_validation.correctly_classified_instances.instances}  Instance</td>
                        </tr>
                        <tr>
                            <td>Incorrectly Classified Instances</td>
                            <td>${output.stratified_cross_validation.incorrectly_classified_instances.value} ${output.stratified_cross_validation.incorrectly_classified_instances.type} ${output.stratified_cross_validation.incorrectly_classified_instances.instances} Instance</td>
                        </tr>
                        <tr>
                            <td>Kappa statistic</td>
                            <td>${output.stratified_cross_validation.kappa_statistic.value}</td>
                        </tr>
                        <tr>
                            <td>Mean absolute error</td>
                            <td>${output.stratified_cross_validation.mean_absolute_error.value}</td>
                        </tr>
                        <tr>
                            <td>Root mean squared error</td>
                            <td>${output.stratified_cross_validation.root_mean_squared_error.value}</td>
                        </tr>
                        <tr>
                            <td>Relative absolute error</td>
                            <td>${output.stratified_cross_validation.relative_absolute_error.value} ${output.stratified_cross_validation.relative_absolute_error.type}</td>
                        </tr>
                        <tr>
                            <td>Root relative squared error</td>
                            <td>${output.stratified_cross_validation.root_relative_squared_error.value} ${output.stratified_cross_validation.relative_absolute_error.type}</td>
                        </tr>
                        <tr>
                            <td>Total Number of Instances</td>
                            <td>${output.stratified_cross_validation.total_number_of_instances.value}</td>
                        </tr>
                    </tbody>
                <table>
            </div>
            <br>
            <h4>Detailed Accuracy By Class</h4>
            <br>
            <canvas id="chart_accuracy" style="height:200px"></canvas>
            <br>
            <div class="table-responsive">
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th></th>
                            <th>TP Rate <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FN )"></i></th>
                            <th>FP Rate <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="FP / ( FP + TN )"></i></th>
                            <th>Precision <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FP )"></i></th>
                            <th>Recall <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content="TP / ( TP + FN )"></i></th>
                            <th>F-Measure <i class="fas fa-info-circle grow icon-info" data-toggle="popover" data-content=" 2 x Precision x Recall / (Precision + Recall)"></i></th>
                            <th>MCC</th>
                            <th>ROC Area</th>
                            <th>PRC Area</th>
                            <th>Class</th>
                        <tr>
                    </thead>
                    <tbody>
                        <tr>
                           <td></td>
                           <td>${output.detailed_accuracy_by_class.tp_rate[0].value}</td>
                           <td>${output.detailed_accuracy_by_class.fp_rate[0].value}</td>
                           <td>${output.detailed_accuracy_by_class.precision[0].value}</td>
                           <td>${output.detailed_accuracy_by_class.recall[0].value}</td>
                           <td>${output.detailed_accuracy_by_class['f-measure'][0].value}</td>
                           <td>${output.detailed_accuracy_by_class.mcc[0].value}</td>
                           <td>${output.detailed_accuracy_by_class.roc_area[0].value}</td>
                           <td>${output.detailed_accuracy_by_class.prc_area[0].value}</td>
                           <td>${output.detailed_accuracy_by_class.class[0].value}</td>
                        </tr>
                        <tr>
                           <td></td>
                           <td>${output.detailed_accuracy_by_class.tp_rate[1].value}</td>
                           <td>${output.detailed_accuracy_by_class.fp_rate[1].value}</td>
                           <td>${output.detailed_accuracy_by_class.precision[1].value}</td>
                           <td>${output.detailed_accuracy_by_class.recall[1].value}</td>
                           <td>${output.detailed_accuracy_by_class['f-measure'][1].value}</td>
                           <td>${output.detailed_accuracy_by_class.mcc[1].value}</td>
                           <td>${output.detailed_accuracy_by_class.roc_area[1].value}</td>
                           <td>${output.detailed_accuracy_by_class.prc_area[1].value}</td>
                           <td>${output.detailed_accuracy_by_class.class[1].value}</td>
                        </tr>
                        <tr>
                           <td>Weighted Avg.</td>
                           <td>${output.detailed_accuracy_by_class.tp_rate[2].value}</td>
                           <td>${output.detailed_accuracy_by_class.fp_rate[2].value}</td>
                           <td>${output.detailed_accuracy_by_class.precision[2].value}</td>
                           <td>${output.detailed_accuracy_by_class.recall[2].value}</td>
                           <td>${output.detailed_accuracy_by_class['f-measure'][2].value}</td>
                           <td>${output.detailed_accuracy_by_class.mcc[2].value}</td>
                           <td>${output.detailed_accuracy_by_class.roc_area[2].value}</td>
                           <td>${output.detailed_accuracy_by_class.prc_area[2].value}</td>
                           <td></td>
                        </tr>
                    <tbody>
                </table>
            </div>
            <br>
            <h4>Confusion Matrix</h4>
            <pre>${confusion_matrix}</pre>
            `;
            $("#outputHtml").html(outHtml);

            $('[data-toggle="popover"]').popover({
                    trigger: "hover",
                    html: true,
                }
            )

            $('[data-toggle="tooltip"]').tooltip(); 

            $("#download_tree").unbind().click(function(){
                let target = document.getElementById("graph");

                html2canvas(target).then(canvas => {
                    saveAs(canvas.toDataURL(), 'file-name.png');
                });
            });

            d3.select("#graph").graphviz()
                .fade(false)
                .renderDot(output.tree);
            this.crateChartAccuracy(output);
        }

        this.getValue = () => {
            return {
                type: this.type,
                confidence_threshold: this.confidence_threshold,
                minimum_number_of_instances: this.minimum_number_of_instances,
                number_of_folds: this.number_of_folds,
            }
        }
    }
}

let state = {
    tabSelect: 'classify-tab',
    outputCluster: null,
    axis_x: 0,
    axis_y: 0
};

class Visualize {
    constructor() {
        let el = {
            axis_x: $("#axis_x"),
            axis_y: $("#axis_y"),
        }
        let axis_x = el.axis_x.val();
        let axis_y = el.axis_y.val();
        let scatter_chart = null;

        let colors = [
            '#E53935',
            '#1E88E5',
            '#43A047',
            '#FB8C00',
            '#28a745',
            '#ffc107',
            '#17a2b8',
            '#fd7e14',
            '#6610f2',
            '#dc3545',
        ];



        let instance_number = [];

        let self = this;

        let clusters = null;

        let optionsChart = {
            responsive: true,

        };

        let createScatterChart = () => {
            if (scatter_chart === null) {
                let ctx = document.getElementById("scatter_chart").getContext('2d');
                scatter_chart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{}]
                    },
                    options: optionsChart
                });
            } else {
                scatter_chart.data.datasets = [{}];
                scatter_chart.update();
            }
            el.axis_x.change();
        }



        let updataChart = () => {
            if (scatter_chart != null) {
                let data = [];

                let keyCluster = Object.keys(clusters);
                for (let i = 0; i < keyCluster.length; i++) {
                    let obj = [];
                    clusters[keyCluster[i]].map(_data => {
                        obj.push({
                            x: _data.values[state.axis_x],
                            y: _data.values[state.axis_y],
                        })
                    })
                    data.push(obj);
                }

                for (let i = 0; i < data.length; i++) {

                    for (let j = 0; j < data[i].length; j++) {
                        if (isNaN(data[i][j].x)) {
                            for (let x = 0; x < state.outputCluster.header.attributes[state.axis_x].labels.length; x++) {

                                if (data[i][j].x === state.outputCluster.header.attributes[state.axis_x].labels[x]) {
                                    data[i][j].x = x;
                                }
                            }
                        } else {
                            data[i][j].x = parseFloat(data[i][j].x);
                        }

                        if (isNaN(data[i][j].y)) {
                            for (let y = 0; y < state.outputCluster.header.attributes[state.axis_y].labels.length; y++) {

                                if (data[i][j].y === state.outputCluster.header.attributes[state.axis_y].labels[y]) {
                                    data[i][j].y = y;
                                }
                            }
                        } else {
                            data[i][j].y = parseFloat(data[i][j].y);
                        }
                    }

                }

                let datasets = [];
                data.map((_data, index) => {
                    let ran = getRndInteger(5, 15);
                    datasets.push({
                        label: 'Cluster' + index,
                        data: _data,
                        pointHoverRadius: ran,
                        pointRadius: ran,
                        borderColor: colors[index],
                        backgroundColor: convertHex(colors[index], 40),
                    })
                });

                scatter_chart.data.datasets = datasets;
                scatter_chart.update();

                let optionsChart = {
                    responsive: true,
                    scales: {
                        xAxes: [{
                            ticks: {
                                // Include a dollar sign in the ticks
                                callback: function (value, index) {
                                    if (state.outputCluster.header.attributes[state.axis_x].type !== "numeric") {
                                        return state.outputCluster.header.attributes[state.axis_x].labels[value];
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }],
                        yAxes: [{
                            ticks: {
                                // Include a dollar sign in the ticks
                                callback: function (value, index) {
                                    if (state.outputCluster.header.attributes[state.axis_y].type !== "numeric") {
                                        return state.outputCluster.header.attributes[state.axis_y].labels[value];
                                    } else {
                                        return value;
                                    }
                                }
                            }
                        }]
                    }

                };
                scatter_chart.options = optionsChart;
                scatter_chart.update();
            }

        }

        this.bindElement = () => {
            el.axis_x.change(function () {
                state.axis_x = $(this).val();
                if (scatter_chart != null) {
                    updataChart();
                }

            });

            el.axis_y.change(function () {
                state.axis_y = $(this).val();
                if (scatter_chart != null) {
                    updataChart();
                }

            })
        }

        this.createAxis = (output) => {
            state.outputCluster = output.outputCluster;
            let html = "";
            output.outputCluster.header.attributes.map((attr, index) => {
                html += `<option value="${index}">${attr.name}</option>`;
            });

            el.axis_x.html(html);
            el.axis_y.html(html);

            for (let i = 0; i < output.outputCluster.data.length; i++) {
                instance_number.push(i);
            }

            clusters = _.groupBy(output.outputCluster.data, d => d.values[d.values.length - 1]);

            createScatterChart();

        }


    }
}

class Analysis {
    constructor() {
        let cluster = new Cluster();
        let associate = new Associate();
        let visualize = new Visualize();
        let j48 = new J48();

        let traningFile = null;
        let output = null;
        let traningFileSelect = "";

        let bindElement = () => {
            $("#btn_process").unbind().click(function () {
                analysisProcess();
            });

            $(".tab-basic .nav-link").unbind().click(function () {
                $("#outputText").html('');
                $("#outputHtml").html('');
                $(".result").hide();
                state.tabSelect = $(this).attr('id');
                d3.select('#graph').selectAll('svg').remove();
                $("#visualize").hide();
            });

            $("#training_file").change(function () {
                traningFileSelect = $(this).val();
            });

            $(".download-file").unbind().click(function(){
                downloadFileResult($(this).attr('type'));
            });
        }

        let downloadFileResult = (type) => {
            if(type === 'text'){
                let blob = new Blob([output.outputText.join("\r\n")], {type: "text/plain;charset=utf-8"});
                FileSaver.saveAs(blob, `file_result.txt`);
            }
            else if(type === 'json'){
                let blob = new Blob([JSON.stringify(output, null, '        ')], {type: "text/plain;charset=utf-8"});
                FileSaver.saveAs(blob, `file_result.json`);
            }
            return;
        }

        let writeOutputHtml = () => {
            let outHtml = "";
            if (state.tabSelect === 'cluster-tab') {
                cluster.writeOutput(output);

            } 
            else if(state.tabSelect === 'associate-tab'){
                associate.writeOutput(output);
            }
            else if (state.tabSelect === 'classify-tab') {
                j48.writeOutput(output);
            }

        }

        let writeOutput = () => {
            let outputText = output.outputText;
            let textarea = "";
            outputText.map(text => {
                textarea += text + "\n";
            });
            $(".result").show();
            $("#outputText").html(textarea);

            if (state.tabSelect === 'cluster-tab') {
                $("#visualize").show();
                visualize.createAxis(output);
            } else if (state.tabSelect === 'classify-tab') {

            } else {
                $("#visualize").hide();
            }
            writeOutputHtml();
        }



        let analysisProcess = () => {
            let data = {};
            let dataInput = null;

            if (state.tabSelect === 'cluster-tab') {
                dataInput = cluster.getValue();
            } else if (state.tabSelect === 'associate-tab') {
                dataInput = associate.getValue();
            } else if (state.tabSelect === 'classify-tab') {
                dataInput = j48.getValue();
            }

            data = {
                type: dataInput.type,
                traningFile: traningFileSelect,
                param: dataInput,
            }

            LOADING.set($("#btn_process"));
            d3.select('#graph').selectAll('svg').remove();
            $.ajax({
                url: END_POINT + 'company/analysis',
                method: 'POST',
                data: data,
                success: (res) => {
                    output = res.data;
                    console.log(output);
                    writeOutput();
                    LOADING.reset($("#btn_process"));
                },
                error: (res) => {
                    console.log(res);
                    LOADING.reset($("#btn_process"));
                }
            });
        }

        let createSelectTraningFile = () => {
            let html = "<option value=''>--Select training file--</option>";
            traningFile.map(file => {
                html += `<option value="${file.data_id}">${file.name}</option>`;
            });
            $("#training_file").html(html);
        }

        let getTraningFile = () => {
            $.ajax({
                url: END_POINT + 'company/analysis/data',
                success: (res) => {
                    traningFile = res.data;
                    console.log(traningFile)
                    createSelectTraningFile();
                },
                error: (res) => {
                    console.log(res)
                }
            })
        };

        this.initAndRun = () => {
            bindElement();
            cluster.bindElement();
            associate.bindElement();
            visualize.bindElement();
            getTraningFile();
        }
    }
}

$(document).ready(function () {
    let analysis = new Analysis();
    analysis.initAndRun();
});
